<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker</title>
      <link href="/2025/11/06/Docker/"/>
      <url>/2025/11/06/Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="01-Docker概述"><a href="#01-Docker概述" class="headerlink" title="01-Docker概述"></a><strong>01-Docker概述</strong></h1><h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><p>Docker是基于Go语言实现的云开源项目。</p><p>Docker的主要目标是：<code>Build, Ship and Run Any App, Anywhere</code>，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP及其运行环境能做到<strong>一次镜像,处处运行</strong>。</p><h2 id="传统虚拟机和容器"><a href="#传统虚拟机和容器" class="headerlink" title="传统虚拟机和容器"></a>传统虚拟机和容器</h2><p>传统虚拟机（virtual machine）：</p><p>传统虚拟机技术基于安装在主操作系统上的虚拟机管理系统（如VirtualBox、VMware等），创建虚拟机（虚拟出各种硬件），在虚拟机上安装从操作系统，在从操作系统中安装部署各种应用。</p><p>缺点：资源占用多、冗余步骤多、启动慢</p><p>Linux容器（Linux Container，简称LXC）：</p><p>Linux容器是与系统其他部分分隔开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。</p><p>Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一的运行。</p><p><img src="https://picbed.algk.com.cn/Docker%E5%9B%BE%E7%89%87/virtual-machine-vs-docker-container.jpg"></p><p>对比：</p><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>大小</td><td>一般为Mb</td><td>一般为Gb</td></tr><tr><td>速度</td><td>接近原生</td><td>比较慢</td></tr><tr><td>系统支持数量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table><h2 id="Docker运行速度快的原因"><a href="#Docker运行速度快的原因" class="headerlink" title="Docker运行速度快的原因"></a>Docker运行速度快的原因</h2><p>Docker有比虚拟机更少的抽象层：</p><p>由于Docker不需要Hypervisor（虚拟机）实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在CPU、内存利用率上docker有明显优势。</p><p>Docker利用的是宿主机的内核，而不需要加载操作系统OS内核：</p><p>当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较耗时耗资源的过程。当新建一个虚拟机时，虚拟机软件需要加载OS，返回新建过程是分钟级别的。而Docker由于直接利用宿主机的操作系统，则省略了返回过程，因此新建一个docker容器只需要几秒钟。</p><p>Docker容器的本质就是一个进程。</p><h2 id="Docker软件"><a href="#Docker软件" class="headerlink" title="Docker软件"></a>Docker软件</h2><p>Docker并非一个通用的容器工具，它依赖于已经存在并运行的Linux内核环境。（在Windows上安装Docker时需要依赖WSL，也即Windows下的Linux子系统）。</p><p>Docker实质上是在已经运行的Linux下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的Linux主机。</p><p>Docker的基本组成部分：</p><ul><li><p>镜像（image）</p></li><li><p>容器（container）</p></li><li><p>仓库（repository）</p></li></ul><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><p>Docker镜像就是一个只读的模板。镜像可以用来创建Docker容器，一个镜像可以创建多个容器。</p><h2 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h2><p>Docker利用容器独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。</p><h2 id="Docker仓库"><a href="#Docker仓库" class="headerlink" title="Docker仓库"></a>Docker仓库</h2><p>Docker仓库是集中存放镜像文件的场所。<br>仓库分为公开仓库和私有仓库两种。<br>最大的公开仓库是Docker官方的Docker Hub：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><p>Docker是一个 C&#x2F;S（Client-Server） 结构的系统，后端是一个松耦合架构，众多模块各司其职。</p><p>Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从容器接收命令并管理运行在主机上的容器。</p><p><img src="https://picbed.algk.com.cn/Docker%E5%9B%BE%E7%89%87/architecture.svg"></p><p>Docker运行的基本流程为：</p><ol><li><p>用户是使用Docker Client 与 Docker Daemon 建立通信，并发送请求给后者</p></li><li><p>Docker Daemon 作为 Docker 架构的主体部分，首先提供 Docker Server 的功能使其可以接收 Docker Client 的请求</p></li><li><p>Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式存在</p></li><li><p>Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph Driver 将下载镜像以 Graph 的形式存储</p></li><li><p>当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境</p></li><li><p>当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Exec driver 来完成</p></li><li><p>Libcontainer 是一项独立的容器管理包，Network driver 以及 Exec driver 都是通过 Libcontainer 来实现具体对容器进行的操作</p></li></ol><p><img src="https://picbed.algk.com.cn/Docker%E5%9B%BE%E7%89%87/flow.png"></p><h1 id="02-Docker安装"><a href="#02-Docker安装" class="headerlink" title="02-Docker安装"></a><strong>02-Docker安装</strong></h1><p><strong>基于centos7版本</strong></p><p>参考官网：<a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p><h2 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h2><p>如果之前安装过Docker，需要先卸载旧版本：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><blockquote><p>旧版本的Docker引擎包可能叫做：<code>docker</code>、<code>docker-engine</code>。</p><p>新版本的Docker引擎包叫做：<code>docker-ce</code></p></blockquote><h2 id="配置yum资源库"><a href="#配置yum资源库" class="headerlink" title="配置yum资源库"></a>配置yum资源库</h2><p>安装<code>yum-config-manager</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum-util提供yum-config-manager功能</span> </span><br><span class="line">sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure><p>配置docker的资源库地址：</p><p>官方地址：（比较慢，不推荐）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在yum资源库中添加docker资源库</span></span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>阿里云镜像地址：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><blockquote><p>阿里云官网提供了很多资源镜像，镜像地址：<code>https://mirrors.aliyun.com</code>，进入之后可以选择自己需要的资源进行配置。</p></blockquote><p>创建缓存（可选）：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><h2 id="安装Docker引擎"><a href="#安装Docker引擎" class="headerlink" title="安装Docker引擎"></a>安装Docker引擎</h2><p>安装最新版本的Docker引擎、Docker客户端：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker-ce是Docker引擎，docker-ce-cli是客户端</span></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure><p>此时，默认安装的docker引擎、客户端都是最新版本。</p><p>如果要安装指定版本：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询版本列表</span></span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定版本安装17.09.0.ce版</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">sudo</span> yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io docker-compose-plugin</span></span><br><span class="line">sudo yum install docker-ce-17.09.0.ce docker-ce-cli-17.09.0.ce containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure><h2 id="启动docker引擎"><a href="#启动docker引擎" class="headerlink" title="启动docker引擎"></a>启动docker引擎</h2><p>如果没有启动Docker引擎，那么执行 <code>docker version</code>查看版本号时，只能看到 <code>Client: Docker Engine</code>（Docker引擎客户端）的版本号。</p><p>启动Docker引擎：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新版本的Docker就是一个系统服务，可以直接使用启动系统服务方式启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时查看docker版本，可以看到Server: Docker Engine（Docker引擎）版本号</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h2 id="配置镜像"><a href="#配置镜像" class="headerlink" title="配置镜像"></a>配置镜像</h2><p>使用<code>vim</code>命令编辑 Docker 守护进程配置文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>在文件中写入以下内容：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://docker.m.daocloud.io&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://1ms.run&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://dockerproxy.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.nju.edu.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://iju9kaj2.mirror.aliyuncs.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://cr.console.aliyun.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://hub.docker.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;http://mirrors.ustc.edu.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://lccijvhq.mirror.aliyuncs.com&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>执行以下命令重载守护进程配置并重启 Docker：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="卸载Docker"><a href="#卸载Docker" class="headerlink" title="卸载Docker"></a>卸载Docker</h2><p>卸载Docker步骤：</p><ol><li>关闭服务</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><ol start="2"><li>使用<code>yum</code>删除docker引擎</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><ol start="3"><li>删除镜像、容器、卷、自定义配置等文件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /var/lib/docker</span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure><h2 id="运行HelloWorld测试"><a href="#运行HelloWorld测试" class="headerlink" title="运行HelloWorld测试"></a>运行HelloWorld测试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><h2 id="配置成系统服务"><a href="#配置成系统服务" class="headerlink" title="配置成系统服务"></a>配置成系统服务</h2><p>将docker添加到systemd：</p><blockquote><p>编辑文件<code>/usr/lib/systemd/system/docker.service</code>。</p><p>文件内容参考：<a href="https://github.com/docker-archive/docker-ce/blob/master/components/engine/contrib/init/systemd/docker.service">github的docker-ce官方文档</a></p></blockquote><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=<span class="string">Docker Application Container Engine</span></span><br><span class="line"><span class="attr">Documentation</span>=<span class="string">https://docs.docker.com</span></span><br><span class="line"><span class="attr">After</span>=<span class="string">network-online.target docker.socket firewalld.service </span></span><br><span class="line"><span class="attr">Wants</span>=<span class="string">network-online.target </span></span><br><span class="line"><span class="attr">Requires</span>=<span class="string">docker.socket</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=<span class="string">notify</span></span><br><span class="line"><span class="attr">ExecStart</span>=<span class="string">/usr/bin/dockerd</span></span><br><span class="line"><span class="attr">ExecReload</span>=<span class="string">/bin/kill -s HUP $MAINPID</span></span><br><span class="line"><span class="attr">TimeoutStartSec</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">RestartSec</span>=<span class="string">2</span></span><br><span class="line"><span class="attr">Restart</span>=<span class="string">always</span></span><br><span class="line"></span><br><span class="line"><span class="attr">StartLimitBurst</span>=<span class="string">3</span></span><br><span class="line"><span class="attr">StartLimitInterval</span>=<span class="string">60s</span></span><br><span class="line"><span class="attr">LimitNOFILE</span>=<span class="string">infinity</span></span><br><span class="line"><span class="attr">LimitNPROC</span>=<span class="string">infinity</span></span><br><span class="line"><span class="attr">LimitCORE</span>=<span class="string">infinity</span></span><br><span class="line"></span><br><span class="line"><span class="attr">TasksMax</span>=<span class="string">infinity</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Delegate</span>=<span class="string">yes</span></span><br><span class="line"></span><br><span class="line"><span class="attr">KillMode</span>=<span class="string">process</span></span><br><span class="line"><span class="attr">OOMScoreAdjust</span>=<span class="string">-500</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=<span class="string">multi-user.target</span></span><br></pre></td></tr></table></figure><p>为<code>docker.service</code>添加执行权限：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x /usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure><h2 id="配置docker"><a href="#配置docker" class="headerlink" title="配置docker"></a>配置docker</h2><p>创建<code>docker</code>组：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groupadd docker</span><br></pre></td></tr></table></figure><p>编辑<code>daemon.json</code>配置文件：</p><blockquote><p>文件：<code>/etc/docker/daemon.json</code></p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 还可以在这个文件中配置加速器、镜像仓库地址等</span><br><span class="line">    &quot;insecure-registries&quot;: [</span><br><span class="line">        // 配置不验证https证书、允许http连接</span><br><span class="line">        &quot;192.168.xxx.xxx:8088&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;data-root&quot;:&quot;/data/docker&quot;,</span><br><span class="line">    &quot;log-driver&quot;:&quot;json-file&quot;,</span><br><span class="line">    &quot;log-opts&quot;:&#123;</span><br><span class="line">        &quot;max-size&quot;:&quot;200m&quot;,&quot;max-file&quot;:&quot;3&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载配置：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><h2 id="启动docker并设置开机自启"><a href="#启动docker并设置开机自启" class="headerlink" title="启动docker并设置开机自启"></a>启动docker并设置开机自启</h2><p>启动docker：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>设置开机自启：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p>检验：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><h2 id="配置命令自动补全"><a href="#配置命令自动补全" class="headerlink" title="配置命令自动补全"></a>配置命令自动补全</h2><p>从docker的github官方仓库获取命令补全的文件：<a href="https://github.com/docker-archive/docker-ce/blob/master/components/cli/contrib/completion/bash/docker">docker</a></p><p>将该文件放到<code>/usr/share/bash-completion/completions</code>，启用该文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /usr/share/bash-completion/completions/docker</span><br></pre></td></tr></table></figure><h1 id="03-Docker常用命令"><a href="#03-Docker常用命令" class="headerlink" title="03-Docker常用命令"></a><strong>03-Docker常用命令</strong></h1><h2 id="启动类命令"><a href="#启动类命令" class="headerlink" title="启动类命令"></a>启动类命令</h2><p>启动docker：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>停止Docker：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><p>重启Docker：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>查看状态：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure><p>设置开机自启：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><h2 id="帮助类命令"><a href="#帮助类命令" class="headerlink" title="帮助类命令"></a>帮助类命令</h2><p>查看Docker版本：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><p>查看Docker概要信息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><p>查看Docker总体帮助文档：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker --help</span><br></pre></td></tr></table></figure><p>查看docker具体命令帮助文档：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker 具体命令 --help</span><br></pre></td></tr></table></figure><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><p><strong>列出本地主机上的镜像:</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><p><code>-a</code>：列出所有镜像（含历史镜像）</p></li><li><p><code>-q</code>：只显示镜像ID</p></li><li><p><code>-f</code>：过滤</p></li></ul><p><strong>在远程仓库中搜索镜像：（默认取docker hub中搜索）</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search 镜像名称</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><p><code>-f</code>：过滤</p></li><li><p><code>--limit 数量</code>：只展示前几项</p></li></ul><p><strong>下载镜像</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull 镜像名称[:tag]</span><br></pre></td></tr></table></figure><p>不加 tag 时，默认下载最新的镜像（即tag为<code>latest</code>）。</p><p><strong>查看占据的空间</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker system df</span><br></pre></td></tr></table></figure><p><strong>删除镜像</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi 镜像名称/ID</span><br></pre></td></tr></table></figure><p>可以使用空格分隔，删除多个镜像：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi 镜像1 镜像2 镜像3</span><br></pre></td></tr></table></figure><p>删除全部镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi -f $(docker images -qa)</span><br></pre></td></tr></table></figure><p><strong>虚悬镜像</strong></p><p>仓库名、标签都是<code>&lt;none&gt;</code>的镜像，俗称虚悬镜像（dangling image）。</p><h1 id="05-容器命令"><a href="#05-容器命令" class="headerlink" title="05-容器命令"></a><strong>05-容器命令</strong></h1><h2 id="新建启动容器"><a href="#新建启动容器" class="headerlink" title="新建启动容器"></a>新建启动容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>常用的参数：</p><ul><li><p><code>--name</code>：为容器指定一个名称</p></li><li><p><code>-d</code>：后台运行容器并返回容器ID，也即启动守护式容器</p></li><li><p><code>-i</code>：以交互模式（interactive）运行容器，通常与<code>-t</code>同时使用</p></li><li><p><code>-t</code>：为容器重新分配一个伪输入终端（tty），通常与<code>-i</code>同时使用。也即启动交互式容器（前台有伪终端，等待交互）</p></li><li><p><code>-e</code>：为容器添加环境变量</p></li><li><p><code>-P</code>：随机端口映射。将容器内暴露的所有端口映射到宿主机随机端口</p></li><li><p><code>-p</code>：指定端口映射</p></li></ul><p><code>-p</code>指定端口映射的几种不同形式：</p><ul><li><p><code>-p hostPort:containerPort</code>：端口映射，例如<code>-p 8080:80</code></p></li><li><p><code>-p ip:hostPort:containerPort</code>：配置监听地址，例如 <code>-p 10.0.0.1:8080:80</code></p></li><li><p><code>-p ip::containerPort</code>：随机分配端口，例如 <code>-p 10.0.0.1::80</code></p></li><li><p><code>-p hostPort1:containerPort1 -p hostPort2:containerPort2</code>：指定多个端口映射，例如<code>-p 8080:80 -p 8888:3306</code></p></li></ul><p><strong>启动交互式容器</strong></p><p>以交互方式启动ubuntu镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-i 交互模式</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-t 分配一个伪输入终端<span class="built_in">tty</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ubuntu 镜像名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/bin/bash（或者bash） shell交互的接口</span></span><br><span class="line">docker run -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>退出交互模式：</p><p>方式1:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在交互shell中<span class="built_in">exit</span>即可退回宿主机</span></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><p>方式2：使用快捷键<code>ctrl</code> + <code>P</code> + <code>Q</code></p><p>方式1 退出后，容器会停止。</p><p>方式2 退出后容器依然正在运行。</p><p><strong>启动守护式容器</strong></p><p>大部分情况下，我们系统docker容器服务时在后台运行的，可以通过<code>-d</code>指定容器的后台运行模式：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d 容器名</span><br></pre></td></tr></table></figure><p>注意事项：</p><p>如果使用<code>docker run -d ubuntu</code>尝试启动守护式的ubuntu，会发现容器启动后就自动退出了。</p><p>因为Docker容器如果在后台运行，就必须要有一个前台进程。容器运行的命令如果不是那些一直挂起的命令（例如<code>top</code>、<code>tail</code>），就会自动退出。</p><h2 id="列出正在运行的容器"><a href="#列出正在运行的容器" class="headerlink" title="列出正在运行的容器"></a>列出正在运行的容器</h2><p>列出所有正在运行的容器：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure><p>常用参数：</p><ul><li><p><code>-a</code>：列出当前所有正在运行的容器+历史上运行过的容器</p></li><li><p><code>-l</code>：显示最近创建的容器</p></li><li><p><code>-n</code>：显示最近n个创建的容器</p></li><li><p><code>-q</code>：静默模式，只显示容器编号</p></li></ul><h2 id="容器其他启停操作"><a href="#容器其他启停操作" class="headerlink" title="容器其他启停操作"></a>容器其他启停操作</h2><p><strong>启动已经停止的容器</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start 容器ID或容器名</span><br></pre></td></tr></table></figure><p><strong>重启容器</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart 容器ID或容器名</span><br></pre></td></tr></table></figure><p><strong>停止容器</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop 容器ID或容器名</span><br></pre></td></tr></table></figure><p><strong>强制停止容器</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker kill 容器ID或容器名</span><br></pre></td></tr></table></figure><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>删除已经停止的容器：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm 容器ID或容器名</span><br></pre></td></tr></table></figure><blockquote><p>删除容器是 <code>docker rm</code>，删除镜像是 <code>docker rmi</code>，注意区分。</p></blockquote><p>强制删除正在运行的容器：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm -f 容器ID或容器名</span><br></pre></td></tr></table></figure><p>一次删除多个容器实例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm -f $&#123;docker ps -a -q&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">docker ps -a -q | xargs docker rm</span><br></pre></td></tr></table></figure><h2 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs 容器ID或容器名</span><br></pre></td></tr></table></figure><h2 id="查看容器内运行的进程"><a href="#查看容器内运行的进程" class="headerlink" title="查看容器内运行的进程"></a>查看容器内运行的进程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker top 容器ID或容器名</span><br></pre></td></tr></table></figure><h2 id="查看容器内部细节"><a href="#查看容器内部细节" class="headerlink" title="查看容器内部细节"></a>查看容器内部细节</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect 容器ID或容器名</span><br></pre></td></tr></table></figure><h2 id="进入正在运行的容器"><a href="#进入正在运行的容器" class="headerlink" title="进入正在运行的容器"></a>进入正在运行的容器</h2><p>进入正在运行的容器，并以命令行交互：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器ID bashShell</span><br></pre></td></tr></table></figure><p>重新进入：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker attach 容器ID</span><br></pre></td></tr></table></figure><p><code>docker exec</code> 和 <code>docker attach</code> 区别：</p><ul><li><p><code>attach</code>直接进入容器启动命令的终端，不会启动新的进程，用<code>exit</code>退出会导致容器的停止</p></li><li><p><code>exec</code>是在容器中打开新的终端，并且可以启动新的进程，用<code>exit</code>退出不会导致容器的停止</p></li></ul><p>如果有多个终端，都对同一个容器执行了 <code>docker attach</code>，就会出现类似投屏显示的效果。一个终端中输入输出的内容，在其他终端上也会同步的显示。</p><h2 id="容器和宿主机文件拷贝"><a href="#容器和宿主机文件拷贝" class="headerlink" title="容器和宿主机文件拷贝"></a>容器和宿主机文件拷贝</h2><p>容器内文件拷贝到宿主机：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp 容器ID:容器内路径 目的主机路径</span><br></pre></td></tr></table></figure><p>宿主机文件拷贝到容器中：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp 主机路径 容器ID:容器内路径</span><br></pre></td></tr></table></figure><h2 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h2><p><code>export</code>：导出容器的内容流作为一个tar归档文件（对应<code>import</code>命令）；</p><p><code>import</code>：从tar包中的内容创建一个新的文件系统再导入为镜像（对应<code>export</code>命令）；</p><p>示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导出</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker <span class="built_in">export</span> 容器ID &gt; tar文件名</span></span><br><span class="line">docker export abc &gt; aaa.tar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导入</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> tar文件 | docker import - 自定义镜像用户/自定义镜像名:自定义镜像版本号</span></span><br><span class="line">cat aaa.tar | docker import - test/mytest:1.0.1</span><br></pre></td></tr></table></figure><h2 id="将容器生成新镜像"><a href="#将容器生成新镜像" class="headerlink" title="将容器生成新镜像"></a>将容器生成新镜像</h2><p><code>docker commit</code>提交容器副本使之成为一个新的镜像。</p><blockquote><p>docker 启动一个镜像容器后， 可以在里面执行一些命令操作，然后使用<code>docker commit</code>将新的这个容器快照生成一个镜像。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 要创建的目标镜像名:[tag]</span><br></pre></td></tr></table></figure><p>Docker挂载主机目录，可能会出现报错：<code>cannot open directory .: Perission denied</code>。</p><p>解决方案：在命令中加入参数 <code>--privileged=true</code>。</p><p>CentOS7安全模块比之前系统版本加强，不安全的会先禁止，目录挂载的情况被默认为不安全的行为，在SELinux里面挂载目录被禁止掉了。如果要开启，一般使用 <code>--privileged=true</code>，扩大容器的权限解决挂载没有权限的问题。也即使用该参数，容器内的root才拥有真正的root权限，否则容器内的root只是外部的一个普通用户权限。</p><h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过UnionFS，提供一些用于持续存储或共享数据。</p><p>特性：卷设计的目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</p><p>特点：</p><ul><li><p>数据卷可以在容器之间共享或重用数据</p></li><li><p>卷中的更改可以直接实施生效</p></li><li><p>数据卷中的更改不会包含在镜像的更新中</p></li><li><p>数据卷的生命周期一直持续到没有容器使用它为止</p></li></ul><p>运行一个带有容器卷存储功能的容器实例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v 宿主机绝对路径目录:容器内目录[rw | ro] 镜像名</span><br></pre></td></tr></table></figure><p>可以使用<code>docker inspect</code>查看容器绑定的数据卷。</p><p>权限：</p><ul><li><p><code>rw</code>：读写 </p></li><li><p><code>ro</code>：只读。如果宿主机写入内容，可以同步给容器内，容器内可以读取。</p></li></ul><p>容器卷的继承：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动一个容器</span></span><br><span class="line">docker run -it --privileged=true -v /tmp/test:/tmp/docker --name u1 ubuntu /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 --volumes-from 继承 u1的容器卷映射配置</span></span><br><span class="line">docker run -it --privileged=true --volumes-from u1 --name u2 ubuntu</span><br></pre></td></tr></table></figure><h2 id="所有命令示意图"><a href="#所有命令示意图" class="headerlink" title="所有命令示意图"></a>所有命令示意图</h2><p><img src="https://picbed.algk.com.cn/Docker%E5%9B%BE%E7%89%87/Docker-Command-Diagram.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2025/11/01/MySQL/"/>
      <url>/2025/11/01/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="SQL-1"><a href="#SQL-1" class="headerlink" title="SQL"></a>SQL</h3><ul><li><p>SQL分类</p><table><thead><tr><th align="center">分类</th><th>说明</th></tr></thead><tbody><tr><td align="center">DDL</td><td>数据定义语言，用来定义数据库对象（数据库，表，字段）</td></tr><tr><td align="center">DML</td><td>数据操作语言，用来对数据库表中的数据进行增删改</td></tr><tr><td align="center">DQL</td><td>数据查询语言，用来查询数据库中表的记录</td></tr><tr><td align="center">DCL</td><td>数据控制语言，用来创建数据库用户、控制数据库访问权限</td></tr></tbody></table></li></ul><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><ul><li><p>DDL-数据库操作</p><ul><li><p>查询</p><p>查询所有数据库</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure><p>查询当前数据库</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> database();</span><br></pre></td></tr></table></figure></li><li><p>创建</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database [if <span class="keyword">not</span> <span class="keyword">exists</span>] 数据库名 [<span class="keyword">default</span> charset 字符集] [<span class="keyword">collate</span> 排序规则];</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> database [if <span class="keyword">exists</span>] 数据库名;</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>DDL-表操作-查询，创建</p><ul><li><p>查询当前数据库所有表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure></li><li><p>查询表结构</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">desc</span> 表明;</span><br></pre></td></tr></table></figure></li><li><p>查询指定表的建表语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create table</span> 表名;</span><br></pre></td></tr></table></figure></li><li><p>创建表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> 表名(</span><br><span class="line">字段<span class="number">1</span> 字段<span class="number">1</span>类型[comment 字段<span class="number">1</span>注释],</span><br><span class="line">字段<span class="number">2</span> 字段<span class="number">2</span>类型[comment 字段<span class="number">1</span>注释],</span><br><span class="line">字段<span class="number">3</span> 字段<span class="number">3</span>类型[comment 字段<span class="number">1</span>注释],</span><br><span class="line">......</span><br><span class="line">字段n 字段n类型[comment 字段<span class="number">1</span>注释]</span><br><span class="line">)[comment 表注释]；</span><br></pre></td></tr></table></figure></li></ul></li><li><p>DDL-表操作-修改,删除</p><ul><li><pre><code class="language-sql">修改数据类型alter table 表名 modify 字段名 新数据类型(长度);修改字段名和字段类型alter table 表名 change 旧字段名 新字段名 类型(长度)[omment 注释][约束];删除字段alter table 表名 drop 字段名;修改表名alter table 表名 rename to 新表名;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```sql</span><br><span class="line">  删除表</span><br><span class="line">  drop table [if exists] 表名;</span><br><span class="line">  删除指定表，并创建该表</span><br><span class="line">  truncate table 表名;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><ul><li><p>DML-添加数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>给指定字段添加数据</span><br><span class="line"><span class="keyword">insert into</span> 表名(字段名<span class="number">1</span>，字段名<span class="number">2</span>,...) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>);</span><br><span class="line"><span class="number">2.</span>给全部字段添加数据</span><br><span class="line"><span class="keyword">insert into</span> 表名 <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,...);</span><br><span class="line"><span class="number">3.</span>批量添加数据</span><br><span class="line"><span class="keyword">insert into</span> 表名(字段名<span class="number">1</span>,字段名<span class="number">2.</span>..) <span class="keyword">values</span>((值<span class="number">1</span>,值<span class="number">2.</span>..),(值<span class="number">1</span>,值<span class="number">2.</span>..),(值<span class="number">1</span>,值<span class="number">2.</span>..));</span><br><span class="line"><span class="keyword">insert into</span> 表名 <span class="keyword">values</span>((值<span class="number">1</span>,值<span class="number">2.</span>..),(值<span class="number">1</span>,值<span class="number">2.</span>..),(值<span class="number">1</span>,值<span class="number">2.</span>..));</span><br></pre></td></tr></table></figure></li><li><p>DML-更新数据,删除数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>更新数据</span><br><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段名<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>,字段值<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span>,...[<span class="keyword">where</span> 条件];</span><br><span class="line"><span class="number">2.</span>删除数据</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件]; </span><br></pre></td></tr></table></figure></li></ul><h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><ul><li><p>DQL-基本查询</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>查询多个字段</span><br><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span>,字段<span class="number">2</span>,字段<span class="number">3.</span>.. <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="number">2.</span>设置别名</span><br><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span>[<span class="keyword">AS</span> 别名<span class="number">1</span>],字段<span class="number">2</span>[<span class="keyword">AS</span> 别名<span class="number">2</span>],字段<span class="number">3</span>[<span class="keyword">AS</span> 别名<span class="number">3</span>]... <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="number">3.</span>去除重复记录</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 字段列表 <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure></li><li><p>DQL-条件查询</p><ul><li><p>语法</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件列表;</span><br></pre></td></tr></table></figure></li><li><p>条件</p><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt; 或 !&#x3D;</td><td>不等于</td></tr><tr><td>between…and…</td><td>在某个范围之内</td></tr><tr><td>in(…)</td><td>在in之后的列表中的值，多选一</td></tr><tr><td>like 占位符</td><td>模糊匹配（_匹配单个字符,%匹配多个字符）</td></tr><tr><td>is null</td><td>是null</td></tr></tbody></table></li></ul></li></ul><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>&amp;&amp; 或 AND</td><td>并且（多个条件同时成立）</td></tr><tr><td>|| 或 OR</td><td>或者（多个条件任意一个成立）</td></tr><tr><td>! 或 NOT</td><td>非，不是</td></tr></tbody></table><ul><li><p>DQL-聚合函数</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">语法：<span class="keyword">select</span> 聚合函数(字段数列) <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure></li><li><p>DQL-分组查询</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>语法</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件] <span class="keyword">group</span> <span class="keyword">by</span> 分组字段名 [<span class="keyword">having</span> 分组后过滤条件];</span><br><span class="line"><span class="number">2.</span><span class="keyword">where</span> 与 <span class="keyword">having</span> 区别</span><br><span class="line">执行时机不同：<span class="keyword">where</span> 是分组之前进行过滤，不满足 <span class="keyword">where</span> 条件，不参与分组；而 <span class="keyword">having</span> 是分组之后对结果进行过滤。</span><br><span class="line">判断条件不同：<span class="keyword">where</span> 不能对聚合函数进行判断，而 <span class="keyword">having</span> 可以。</span><br></pre></td></tr></table></figure></li><li><p>DQL-排序查询</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 语法</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">order</span> <span class="keyword">by</span> 字段<span class="number">1</span> 排序方式<span class="number">1</span>,字段<span class="number">2</span> 排序方式<span class="number">2</span> ;</span><br><span class="line"><span class="number">2.</span> 排序方式</span><br><span class="line"><span class="keyword">ASC</span>：升序（默认值）</span><br><span class="line"><span class="keyword">DESC</span>：降序</span><br><span class="line">注意：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序。</span><br></pre></td></tr></table></figure></li><li><p>DQL-分页查询</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>语法</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 LIMIT 起始索引, 查询记录数;</span><br><span class="line">注意</span><br><span class="line">· 起始索引从<span class="number">0</span>开始，起始索引 <span class="operator">=</span> (查询页码 <span class="operator">-</span> <span class="number">1</span>) <span class="operator">*</span> 每页显示记录数。</span><br><span class="line">· 分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。</span><br><span class="line">· 如果查询的是第一页数据，起始索引可以省略，直接简写为 limit <span class="number">10</span>。</span><br></pre></td></tr></table></figure></li><li><p>DQL-执行顺序</p><img src="C:\Users\46814\AppData\Roaming\Typora\typora-user-images\image-20251021212510152.png" alt="image-20251021212510152" style="zoom: 67%;" /></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p>字符串函数</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(S1,S2,…Sn)</td><td>字符串拼接，将 S1，S2，… Sn 拼接成一个字符串</td></tr><tr><td>LOWER(str)</td><td>将字符串 str 全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串 str 全部转为大写</td></tr><tr><td>LPAD(str,n,pad)</td><td>左填充，用字符串 pad 对 str 的左边进行填充，达到 n 个字符串长度</td></tr><tr><td>RPAD(str,n,pad)</td><td>右填充，用字符串 pad 对 str 的右边进行填充，达到 n 个字符串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTING(str,start,len)</td><td>返回从字符串 str 从 start 位置起的 len 个长度的字符串</td></tr></tbody></table></li><li><p>数值函数</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CELL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x,y)</td><td>返回x&#x2F;y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数</td></tr><tr><td>ROUND(x,y)</td><td>求参数x的四舍五入的值，保留y为小数</td></tr></tbody></table></li><li><p>日期函数</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>curdate()</td><td>返回当前日期</td></tr><tr><td>curtime()</td><td>返回当前时间</td></tr><tr><td>now()</td><td>返回当前日期和时间</td></tr><tr><td>year(date)</td><td>获得指定date的年份</td></tr><tr><td>month(date)</td><td>获得指定date的月份</td></tr><tr><td>day(date)</td><td>获得指定date的日期</td></tr><tr><td>date_add(date,interval expr type)</td><td>返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值</td></tr><tr><td>datediff(date1,date2)</td><td>返回起始时间date1和结束时间date2之间的天数</td></tr></tbody></table></li><li><p>流程函数</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>if(value , t, f)</td><td>如果 value 为 true，则返回 t，否则返回 f</td></tr><tr><td>IFNULL(value1 , value2)</td><td>如果 value1 不为空，返回 value1，否则返回 value2</td></tr><tr><td>CASE WHEN [val1] THEN [res1] … ELSE [default] END</td><td>如果 val1 为 true，返回 res1，… 否则返回 default 默认值</td></tr><tr><td>CASE [expr] WHEN [val1] THEN [res1] … ELSE [default] END</td><td>如果 expr 的值等于 val1，返回 res1，… 否则返回 default 默认值</td></tr></tbody></table></li></ul><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ul><li><p>约束概要</p><ul><li><p>概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。</p></li><li><p>目的：保证数据库中数的正确、有效性和完整性。</p></li><li><p>分类</p><table><thead><tr><th>约束</th><th>描述</th><th>关键词</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>not null</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复</td><td>unique</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>primary key</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>default</td></tr><tr><td>检查约束</td><td>保证字段值满足某一个条件</td><td>check</td></tr><tr><td>外键约束</td><td>用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td><td>foreign key</td></tr></tbody></table></li></ul></li><li><p>外键</p><ul><li><p>添加外键</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> 表名(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">    ...</span><br><span class="line">    [<span class="keyword">constraint</span>] [外键名称] <span class="keyword">foreign key</span>(外键字段名) <span class="keyword">references</span> 主表(主列表名);</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">add constraint</span> 外键名称 <span class="keyword">foreign key</span>(外键字段名) <span class="keyword">references</span> 主表(主列表名)；</span><br></pre></td></tr></table></figure></li><li><p>删除外键</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">drop</span> <span class="keyword">foreign key</span> 外键名称;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>删除更新行为</p><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除 &#x2F; 更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除 &#x2F; 更新。(与 RESTRICT 一致)</td></tr><tr><td>RESTRICT</td><td>当在父表中删除 &#x2F; 更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除 &#x2F; 更新。(与 NO ACTION 一致)</td></tr><tr><td>CASCADE</td><td>当在父表中删除 &#x2F; 更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除 &#x2F; 更新外键在子表中的记录。</td></tr><tr><td>SET NULL</td><td>当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为 null（这就要求该外键允许取 null）。</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> 表名 <span class="keyword">ADD CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN KEY</span> (外键字段) <span class="keyword">REFERENCES</span> 主表名 (主表字段名) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE;</span><br></pre></td></tr></table></figure></li></ul><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><ul><li><p>多表查询-多表关系</p><ul><li><p>一对多</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">案例：部门与员工的关系</span><br><span class="line">关系：一个部门对应多个员工，一个员工对应一个部门</span><br><span class="line">实现：在多的一方建立外键，指向一的一方的主键</span><br></pre></td></tr></table></figure></li><li><p>多对多</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">案例：学生与课程的关系</span><br><span class="line">关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择</span><br><span class="line">实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</span><br></pre></td></tr></table></figure></li><li><p>一对一</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">案例：用户与用户详情的关系</span><br><span class="line">关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率</span><br><span class="line">实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的 (UNIQUE)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul><li><p>多表查询-内连接</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">内连接查询的是两张表交集的部分</span><br><span class="line"><span class="number">1.</span>隐式内连接</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span>,表<span class="number">2</span> <span class="keyword">where</span> 条件...;</span><br><span class="line"><span class="number">2.</span>显式内连接</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> [<span class="keyword">inner</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 连接条件...;</span><br></pre></td></tr></table></figure></li><li><p>多表查询-外连接</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>左外连接(查询表<span class="number">1</span>与表<span class="number">2</span>交集部分)</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">left</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件...;</span><br><span class="line"><span class="number">2.</span>右外连接</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">right</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件...;</span><br></pre></td></tr></table></figure></li><li><p>多表查询-自连接</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表A 别名A <span class="keyword">join</span> 表B 别名B <span class="keyword">on</span> 条件...;</span><br></pre></td></tr></table></figure></li><li><p>多表查询-联合查询</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表A...</span><br><span class="line"><span class="keyword">union</span>[<span class="keyword">all</span>]</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表B...;</span><br></pre></td></tr></table></figure></li><li><p>子查询</p><ul><li><p>标量子查询</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子查询返回的结果是单个值</span><br><span class="line">常用操作符 = &lt;&gt; &gt; &gt;= &lt; &lt;=</span><br></pre></td></tr></table></figure></li><li><p>列子查询</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子查询返回的结果是一列</span><br><span class="line">常用操作符 IN &quot;NOT NULL&quot; ANY SOME ALL</span><br></pre></td></tr></table></figure></li><li><p>行子查询</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子查询返回的是一行(可以是多列)</span><br><span class="line">常用操作符 = &lt;&gt; IN &quot;NOT IN&quot;</span><br></pre></td></tr></table></figure></li><li><p>表子查询</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常用操作符为 IN</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><ul><li><p>DCL-用户管理</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DCL<span class="operator">-</span>管理用户</span><br><span class="line"><span class="number">1.</span> 查询用户</span><br><span class="line">USE mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="number">2.</span> 创建用户</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span></span><br><span class="line">IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>;</span><br><span class="line"><span class="number">3.</span> 修改用户密码</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span></span><br><span class="line">IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span>;</span><br><span class="line"><span class="number">4.</span> 删除用户</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>DCL-权限控制</p></li></ul><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>SELECT</td><td>查询权限</td></tr><tr><td>INSERT</td><td>插入权限</td></tr><tr><td>UPDATE</td><td>修改权限</td></tr><tr><td>DELETE</td><td>删除权限</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库&#x2F;表&#x2F;视图</td></tr><tr><td>CREATE</td><td>创建数据库&#x2F;表</td></tr><tr><td>ALL, ALL PRIVILEGES</td><td>所有权限</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">查询权限<span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br><span class="line">授予权限<span class="keyword">GRANT</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">TO</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br><span class="line">撤销权限<span class="keyword">REVOKE</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">FROM</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p></blockquote><ul><li>方法一</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">查看<span class="operator">/</span>设置事务的提交方式</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@autocommit</span>;</span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@autocommit</span><span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">提交事务</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line">回滚事务</span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><ul><li>方法2</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">开启事务</span><br><span class="line"><span class="keyword">start</span> transaction 或 <span class="keyword">begin</span></span><br></pre></td></tr></table></figure><ul><li>事务的四大特性</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</span><br><span class="line">一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</span><br><span class="line">隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</span><br><span class="line">持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</span><br></pre></td></tr></table></figure><ul><li><p>并发事务的问题</p><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另外一个事务还没有提交的数据。</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了 “幻影”。</td></tr></tbody></table></li><li><p>事务的隔离级别</p><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">Read uncommitted</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Read committed</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Repeatable Read (默认)</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">Serializable</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看事务隔离级别SELECT @@TRANSACTION_ISOLATION;</span></span><br><span class="line"><span class="comment">-- 设置事务隔离级别SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h1><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><ul><li><p>存储引擎-MySQL体系结构</p><p><img src="https://picbed.algk.com.cn/MySQLimage-20251025134717679.png" alt="image-20251025134717679"></p></li></ul><ul><li><p>存储引擎-简介</p><ul><li><p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可以被称为表类型。</p></li><li><p>建表语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> 表名(</span><br><span class="line">字段<span class="number">1</span> 字段<span class="number">1</span>类型[comment 字段<span class="number">1</span>注释],</span><br><span class="line">字段<span class="number">2</span> 字段<span class="number">2</span>类型[comment 字段<span class="number">2</span>注释],</span><br><span class="line">字段<span class="number">3</span> 字段<span class="number">3</span>类型[comment 字段<span class="number">3</span>注释],</span><br><span class="line">......</span><br><span class="line">字段n 字段n类型[comment 字段n注释]</span><br><span class="line">)engine <span class="operator">=</span> innodb [comment 表注释]；</span><br></pre></td></tr></table></figure></li><li><p>查数据库支持哪些存储引擎</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>存储引擎-innoDB介绍。</p><ul><li><p>介绍</p><p>innoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 存储引擎。</p></li><li><p>特点</p><p>1.DML 操作遵循 ACID 模型，支持<strong>事务</strong>；</p><p>2.<strong>行级锁</strong>，提高并发访问性能；</p><p>3.支持<strong>外键</strong>FOREIGN KEY 约束，保证数据的完整性和正确性；</p></li><li><p>文件</p><p>xxx.ibd: xxx 代表的是表名，innoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。（ibd2sdi ibd文件）</p></li><li><p>逻辑存储结构</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251025142440026.png" alt="image-20251025142440026"></p></li></ul></li><li><p>存储引擎-MyISAM和Memory</p><ul><li><p>MyISAM</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">介绍</span><br><span class="line">MyISAM 是 MySQL 早期的默认存储引擎。</span><br><span class="line">特点</span><br><span class="line">不支持事务，不支持外键</span><br><span class="line">支持表锁，不支持行锁</span><br><span class="line">访问速度快</span><br><span class="line">文件</span><br><span class="line">xxx.sdi：存储表结构信息</span><br><span class="line">xxx.MYD：存储数据</span><br><span class="line">xxx.MYI：存储索引</span><br></pre></td></tr></table></figure></li><li><p>Memory</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">介绍</span><br><span class="line">Memory 引擎的表数据是存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。</span><br><span class="line">特点</span><br><span class="line">内存存放</span><br><span class="line">hash 索引（默认）</span><br><span class="line">文件</span><br><span class="line">xxx.sdi：存储表结构信息</span><br></pre></td></tr></table></figure></li></ul></li><li><p>存储引擎-选择</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InnoDB：是 Mysql 的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么 InnoDB 存储引擎是比较合适的选择。</span><br><span class="line">MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</span><br><span class="line">MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY 的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</span><br></pre></td></tr></table></figure></li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul><li><p>索引-概述</p><ul><li><p>索引是帮助MySQL高效获取数据的数据结构(有序)。</p></li><li><table><thead><tr><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>提高数据检索的效率，降低数据库的 IO 成本</td><td>索引列也是要占用空间的。</td></tr><tr><td>通过索引列对数据进行排序，降低数据排序的成本，降低 CPU 的消耗。</td><td>索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行 INSERT、UPDATE、DELETE 时，效率降低。</td></tr></tbody></table></li></ul></li></ul><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><ul><li><p>索引结构</p><table><thead><tr><th>索引结构</th><th align="center">描述</th></tr></thead><tbody><tr><td>B+Tree 索引</td><td align="center">最常见的索引类型，大部分引擎都支持 B+ 树索引</td></tr><tr><td>Hash 索引</td><td align="center">底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询</td></tr></tbody></table></li><li><p>索引-结构</p><ul><li><p>Btree</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251025222431224.png" alt="image-20251025222431224"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">具体动态变化的过程可以参考网站: https://www.cs.usfca.edu/~galles/visualization/BTree.html</span><br></pre></td></tr></table></figure></li><li><p>B+tree</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251025222903543.png" alt="image-20251025222903543"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">区别：所有节点都会出现在叶子节点，叶子节点形成一个单向链表。</span><br></pre></td></tr></table></figure></li><li><p>hash</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251026101311701.png" alt="image-20251026101311701"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特点：</span><br><span class="line">1. Hash索引只能用于对等比较(=,in),不支持范围查询(bewteen,&gt;,&lt;,...)</span><br><span class="line">2.无法利用索引完成排序操作</span><br><span class="line">3.查询效率高，通常只需要一次检索就可以，效率通常要高于B+tree索引。</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="索引分类-语法"><a href="#索引分类-语法" class="headerlink" title="索引分类&amp;&amp;语法"></a>索引分类&amp;&amp;语法</h3><ul><li><p>索引-分类</p><ul><li><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引 (Clustered Index)</td><td>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只有一个</td></tr><tr><td>二级索引 (Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table></li><li><p>聚集索引选取规则</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果存在主键，主键索引就是聚集索引。</span><br><span class="line">如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</span><br><span class="line">如果表没有主键，或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引。</span><br></pre></td></tr></table></figure></li></ul></li><li><p>索引-语法</p><ul><li><p>创建索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span><span class="operator">|</span>fulltext] index index_name <span class="keyword">on</span> table_name (index_col_name...);</span><br></pre></td></tr></table></figure></li><li><p>查看索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>删除索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index index_name <span class="keyword">on</span> table_name;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>索引-性能分析</p><ul><li><p>查看执行频次</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">查看数据库语句访问频次</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>慢查询日志</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认 <span class="number">10</span> 秒）的所有 <span class="keyword">SQL</span> 语句的日志。</span><br><span class="line">MySQL 的慢查询日志默认没有开启，需要在 MySQL 的配置文件（<span class="operator">/</span>etc<span class="operator">/</span>my.cnf）中配置如下信息：</span><br><span class="line">#开启MySQL慢日志查询开关</span><br><span class="line">slow_query_log<span class="operator">=</span><span class="number">1</span></span><br><span class="line">#设置慢日志的时间为<span class="number">2</span>秒，<span class="keyword">SQL</span>语句执行时间超过<span class="number">2</span>秒，就会视为慢查询，记录慢查询日志</span><br><span class="line">long_query_time<span class="operator">=</span><span class="number">2</span></span><br><span class="line">配置完后，通过以下指令重启MySQL服务器进行测试，查看满日志文件中记录的信息<span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>localhost<span class="operator">-</span>slow.log</span><br></pre></td></tr></table></figure></li></ul></li><li><p>show profiles</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@have_profiling;</span><br><span class="line">开启profiling:set profiling=1;</span><br><span class="line">#查看每一条SQL的耗时基本情况</span><br><span class="line">show profiles;</span><br><span class="line">#查看指定query_id的SQL语句的各个阶段的耗时情况。</span><br><span class="line">show profile for query query_id;</span><br><span class="line">#查询指定query_id的SQL语句的CPU使用情况。</span><br><span class="line">show profile cpu for query query_id;</span><br></pre></td></tr></table></figure><ul><li><p>explain</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Id</span><br><span class="line">select 查询的序列号，表示查询中执行 select 子句或者是操作表的顺序 (id 相同，执行顺序从上到下；id 不同，值越大，越先执行)。</span><br><span class="line">#select_type</span><br><span class="line">表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE 之后包含了子查询）等</span><br><span class="line">#type（重要）</span><br><span class="line">表示连接类型，性能由好到差的连接类型为 NULL、system、const(根据主键和唯一索引查询)、eq_ref、ref(非唯一索引)、range、 index、all 。</span><br><span class="line">#possible_key</span><br><span class="line">显示可能应用在这张表上的索引，一个或多个。</span><br><span class="line">#Key</span><br><span class="line">实际使用的索引，如果为 NULL，则没有使用索引。</span><br><span class="line">#Key_len</span><br><span class="line">表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。</span><br><span class="line">#rows</span><br><span class="line">MySQL 认为必须要执行查询的行数，在 innodb 引擎的表中，是一个估计值，可能并不总是准确的。</span><br><span class="line">#filtered</span><br><span class="line">表示返回结果的行数占需读取行数的百分比，filtered 的值越大越好。</span><br></pre></td></tr></table></figure></li></ul></li><li><p>索引-使用规则</p><ul><li><p>最左前缀法则</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最左前缀法则：如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效 (后面的字段索引失效)。当出现范围查询时，范围查询的右侧列索引失效。</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ul><li><p>索引失效</p><ul><li><p>不要在索引列表上进行运算操作，索引将失效。</p></li><li><p>字符串类型字段使用时，不加引号，索引将失效。</p></li><li><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p></li><li><p>用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及到的索引用不到。</p></li><li><p>如果MySQL评估使用索引比全表更慢，索引失效。</p></li><li><p>SQL提示</p><ul><li><p>SQL提示是优化数据库的重要手段，就是在SQL语句中加入一些人为的提示来达到目的</p></li><li><p>index</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from tb_user use index(idx_user_pro) where profession=&#x27;软件工程&#x27;。</span><br><span class="line">## use index表示使用该索引，ignore表示忽略，force表示强制。 </span><br></pre></td></tr></table></figure></li></ul></li><li><p>覆盖索引</p><ul><li>尽量使用覆盖索引（也就是说查询的字段，在使用的索引中都包含，也就是减少回表查询），减少select*。</li></ul></li><li><p>前缀索引</p><ul><li><p>当字段类型为字符串（varchar，text 等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘 IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p></li><li><p>语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create index idx_xxxx on table_name(column(n));</span><br></pre></td></tr></table></figure></li><li><p>前缀长度</p><p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(distinct substring(字段值,1，5))/count(*) from tb_user;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>思考</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.为什么InnoDB存储引擎选择使用B+tree索引结构？</span><br><span class="line">相对于二叉树，层级更少，搜索效率高。</span><br><span class="line">对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低。</span><br></pre></td></tr></table></figure></li><li><p>使用原则</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">针对于数据量较大，且查询比较频繁的表建立索引。</span><br><span class="line">针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</span><br><span class="line">尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</span><br><span class="line">如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</span><br><span class="line">尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</span><br><span class="line">要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</span><br><span class="line">如果索引列不能存储 NULL 值，请在创建表时使用 NOT NULL 约束它。当优化器知道每列是否包含 NULL 值时，它可以更好地确定哪个索引最有效地用于查询。</span><br></pre></td></tr></table></figure></li></ul><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="insert优化"><a href="#insert优化" class="headerlink" title="insert优化"></a>insert优化</h3><ul><li><p>批量插入</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Insert into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>手动提交事务</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">insert into</span> tb_test <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">5</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">6</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">insert into</span> tb_test <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">8</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">9</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></li><li><p>主键顺序插入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主键乱序插入：8 1 9 21 88 2 4 15 89 5 7 3</span><br><span class="line">主键顺序插入：1 2 3 4 5 7 8 9 15 21 88 89</span><br></pre></td></tr></table></figure></li><li><p>大批量插入数据(load)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#客户端连接服务端时，加上参数 <span class="comment">--local-infile。</span></span><br><span class="line">mysql <span class="comment">--local-infile -u root -p</span></span><br><span class="line">#设置全局参数 local_infile 为 <span class="number">1</span>，开启从本地加载文件导入数据的开关。</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">#执行 load 指令将准备好的数据，加载到表结构中。</span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;/root/sql1.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> tb_user fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><ul><li>页分裂<br><img src="https://picbed.algk.com.cn/MySQL/image-20251027194910387.png" alt="image-20251027194910387"></li><li>页合并<br><img src="https://picbed.algk.com.cn/MySQL/image-20251027195035830.png" alt="image-20251027195035830"></li><li>主键设计原则<ul><li>满足业务需求的情况下，尽量降低主键的长度。</li><li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li><li>尽量不要使用UUID做主键或者时其他自然主键，如身份证号。</li><li>业务操作时，避免对主键的修改。</li></ul></li></ul><h3 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h3><blockquote><p>①. Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。<br>②. Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</p></blockquote><ul><li>order by优化<ul><li>根据排序字段建立合适的索引，多字段排序时，页遵循最左前缀法则。</li><li>尽量使用覆盖索引。</li><li>多字段排序，一个升序一个降序，此时要注意联合索引创建的规则(ASD&#x2F;DESC)。</li><li>如果不可避免的出现 filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size (默认 256k)</li></ul></li></ul><h3 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h3><ul><li>group by优化<ul><li>在分组操作时，可以通过索引来提高效率。</li><li>在分组操作时，索引的使用也满足最左前缀法则。</li></ul></li></ul><h3 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h3><ul><li><p>优化思路</p><p>一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_sku t , (<span class="keyword">select</span> id <span class="keyword">from</span> tb_sku <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">2000000</span>,<span class="number">10</span>) a <span class="keyword">where</span> t.id <span class="operator">=</span> a.id;</span><br></pre></td></tr></table></figure></li></ul><h3 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h3><ul><li>count的几种用法<ul><li><strong>count(主键)</strong><br>InnoDB 引擎会遍历整张表，把每一行的主键 id 值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加 (主键不可能为 null)。</li><li><strong>count(字段)</strong><ul><li>没有 not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为 null，不为 null，计数累加。</li><li>有 not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</li></ul></li><li><strong>count(1)</strong><br>InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字 “1” 进去，直接按行进行累加。</li><li><strong>count(*)</strong><br>InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。</li></ul></li></ul><blockquote><p>按照效率排序的话，<code>count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*) </code>，所以尽量使用 <code>count(*)</code>。</p></blockquote><h3 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h3><ul><li>InnoDB的行级锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行级锁升级为表锁。</li></ul><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="介绍及基本语法"><a href="#介绍及基本语法" class="headerlink" title="介绍及基本语法"></a>介绍及基本语法</h3><ul><li><p>介绍</p><p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p></li><li><p>语法</p><ul><li><p>创建</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">or</span> replace] <span class="keyword">view</span> 视图名称[(列表名称)] <span class="keyword">AS</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span>[<span class="keyword">cascaded</span><span class="operator">|</span><span class="keyword">local</span>] <span class="keyword">check</span> option];</span><br></pre></td></tr></table></figure></li><li><p>查询</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">查看创建视图语句：<span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> 视图名称;</span><br><span class="line">查看视图数据：   <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 视图名称......;</span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">方式一：<span class="keyword">create</span> [<span class="keyword">or</span> replace] <span class="keyword">view</span> 视图名称[(列表名称)] <span class="keyword">AS</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span>[<span class="keyword">cascaded</span><span class="operator">|</span><span class="keyword">local</span>] <span class="keyword">check</span> option];</span><br><span class="line">方式二：<span class="keyword">alter</span> <span class="keyword">view</span> 视图名称[(列表名称)] <span class="keyword">AS</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span>[<span class="keyword">cascaded</span><span class="operator">|</span><span class="keyword">local</span>] <span class="keyword">check</span> option];</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> [if <span class="keyword">exists</span>] 视图名称</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="检查选项"><a href="#检查选项" class="headerlink" title="检查选项"></a>检查选项</h3><blockquote><p>当使用<code>WITH CHECK OPTION</code>子句创建视图时，MySQL 会通过视图检查正在更改的每个行，例如插入、更新、删除，以使其符合视图的定义。MySQL 允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql 提供了两个选项：<code>CASCADED</code>和<code>LOCAL</code>，默认值为<code>CASCADED</code>。</p></blockquote><h4 id="cascaded"><a href="#cascaded" class="headerlink" title="cascaded"></a>cascaded</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">20</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v2 <span class="keyword">as</span> <span class="keyword">select</span> id , name <span class="keyword">from</span> v1 <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">10</span> <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option ;</span><br></pre></td></tr></table></figure><blockquote><p>如果加了cascaded要检测当前视图条件还要检测关联的视图条件。关联权限有检查权限。</p></blockquote><h4 id="local"><a href="#local" class="headerlink" title="local"></a>local</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">15</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v2 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> v1 <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">10</span> <span class="keyword">with</span> <span class="keyword">local</span> <span class="keyword">check</span> option ;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v3 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> v2 <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><blockquote><p>关联视图没有检查权限</p></blockquote><h3 id="更新及作用"><a href="#更新及作用" class="headerlink" title="更新及作用"></a>更新及作用</h3><ul><li><p>注意</p><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新：</p><ol><li>聚合函数或窗口函数（SUM ()、MIN ()、MAX ()、COUNT () 等）</li><li>DISTINCT</li><li>GROUP BY</li><li>HAVING</li><li>UNION 或者 UNION ALL</li></ol></li><li><p>作用</p><ul><li><strong>简单</strong><br>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</li><li><strong>安全</strong><br>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据</li><li><strong>数据独立</strong><br>视图可帮助用户屏蔽真实表结构变化带来的影响。</li></ul></li></ul><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><blockquote><p>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>封装，复用</li><li>可以接受参数，也可以返回参数</li><li>减少网络交互，效率提升。</li></ul><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul><li><p>创建</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称([参数列表])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment">--SQL语句</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li><li><p>调用</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> 名称 ([参数]);</span><br></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.routines <span class="keyword">where</span> routines_schema <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span>;<span class="comment">--查询指定数据库存储过程及状态信息。</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称： <span class="comment">--查询某个存储过程的定义</span></span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> [if <span class="keyword">exists</span>] 存储过程名称;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在命令行中，执行创建存储过程的SQL时，需要通过关键字delimiter指定SQL语句的结束符。</p></blockquote></li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><blockquote><p><strong>系统变量</strong>时MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量(global)和会话变量(session).</p></blockquote><ul><li><p>查看系统变量</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> [session<span class="operator">|</span><span class="keyword">global</span>] variables;<span class="comment">--查看所有系统变量</span></span><br><span class="line"><span class="keyword">show</span> [session<span class="operator">|</span><span class="keyword">global</span>] variables <span class="keyword">like</span> <span class="string">&#x27;......&#x27;</span>;  <span class="comment">--模糊匹配查找</span></span><br><span class="line"><span class="keyword">select</span> @@[session<span class="operator">|</span><span class="keyword">global</span>] 系统变量名; <span class="comment">--查看指定变量的值</span></span><br></pre></td></tr></table></figure></li><li><p>设置系统变量</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> [session<span class="operator">|</span><span class="keyword">global</span>] 系统变量名 <span class="operator">=</span> 值</span><br><span class="line"><span class="keyword">set</span> @@[session<span class="operator">|</span><span class="keyword">global</span>] 系统变量名 <span class="operator">=</span> 值</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意:如果没有指定 SESSION&#x2F;GLOBAL，默认是 SESSION，会话变量。mysql 服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在 &#x2F;etc&#x2F;my.cnf 中配置。</p></blockquote><h4 id="用户自定义变量"><a href="#用户自定义变量" class="headerlink" title="用户自定义变量"></a>用户自定义变量</h4><blockquote><p><strong>用户定义变量</strong>是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 “@变量名” 使用就可以。其作用域为当前连接。</p></blockquote><ul><li><p>赋值</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@var_name</span> <span class="operator">=</span> expr [, <span class="variable">@var_name</span> <span class="operator">=</span> expr] ... ;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr [, <span class="variable">@var_name</span> :<span class="operator">=</span> expr] ... ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr [, <span class="variable">@var_name</span> :<span class="operator">=</span> expr] ... ;</span><br><span class="line"><span class="keyword">SELECT</span> 字段名 <span class="keyword">INTO</span> <span class="variable">@var_name</span> <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="variable">@var_name</span>;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：用户自定义的变量无需对其进行声明或初始化，只不过获取的职位NULL；</p></blockquote><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><blockquote><p><strong>局部变量</strong>是根据需要定义的在局部生效的变量，访问之前，需要 DECLARE 声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的 BEGIN … END 块。</p></blockquote><ul><li><p>声明</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 变量名 变量类型 [<span class="keyword">DEFAULT</span> ...];</span><br></pre></td></tr></table></figure><blockquote><p>变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME 等。</p></blockquote></li><li><p>赋值</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> 变量名 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">SET</span> 变量名 :<span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">SELECT</span> 字段名 <span class="keyword">INTO</span> 变量名 <span class="keyword">FROM</span> 表名 ... ;</span><br></pre></td></tr></table></figure></li></ul><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><ul><li><p>语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">IF 条件 <span class="number">1</span> <span class="keyword">THEN</span></span><br><span class="line">......</span><br><span class="line">ELSEIF 条件 <span class="number">2</span> <span class="keyword">THEN</span>    <span class="comment">-- 可选</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">ELSE</span>  <span class="comment">-- 可选</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">END</span> IF;</span><br></pre></td></tr></table></figure></li></ul><h3 id="参数-IN-、OUT、INOUT"><a href="#参数-IN-、OUT、INOUT" class="headerlink" title="参数(IN 、OUT、INOUT)"></a>参数(IN 、OUT、INOUT)</h3><ul><li><p>参数</p><table><thead><tr><th>参数</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>IN</td><td>该类参数作为输入，也就是需要调用时传入值</td><td>默认</td></tr><tr><td>OUT</td><td>该类参数作为输出，也就是该参数可以作为返回值</td><td></td></tr><tr><td>INOUT</td><td>既可以作为输入参数，也可以作为输出</td><td></td></tr></tbody></table></li><li><p>用法</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称([<span class="keyword">IN</span><span class="operator">/</span><span class="keyword">OUT</span><span class="operator">/</span><span class="keyword">INOUT</span> 参数名 参数类型])</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- SQL语句</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><ul><li><p>语法一</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CASE</span> case_value</span><br><span class="line">    <span class="keyword">WHEN</span> when_value1 <span class="keyword">THEN</span> statement_list1</span><br><span class="line">    [ <span class="keyword">WHEN</span> when_value2 <span class="keyword">THEN</span> statement_list2 ] ...</span><br><span class="line">    [ <span class="keyword">ELSE</span> statement_list ]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure></li><li><p>语法二</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> search_condition1 <span class="keyword">THEN</span> statement_list1</span><br><span class="line">    [<span class="keyword">WHEN</span> search_condition2 <span class="keyword">THEN</span> statement_list2] ...</span><br><span class="line">    [<span class="keyword">ELSE</span> statement_list]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><ul><li><p>语法</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">WHILE 条件 DO</span><br><span class="line"><span class="keyword">SQL</span> 逻辑...</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br></pre></td></tr></table></figure></li></ul><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><ul><li><p>语法</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#先执行一次逻辑，然后判定逻辑是否满足，如果满足，则退出。如果不满足，则继续下一次循环</span><br><span class="line">REPEAT</span><br><span class="line"><span class="keyword">SQL</span> 逻辑...</span><br><span class="line">UNTIL 条件</span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br></pre></td></tr></table></figure></li></ul><h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><blockquote><p>LOOP 实现简单的循环，如果不在 SQL 逻辑中增加退出循环的条件，可以用其来实现简单的死循环。LOOP 可以配合以下两个语句使用：</p><ul><li>LEAVE：配合循环使用，退出循环。</li><li>ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[begin_label:] loop</span><br><span class="line">    <span class="keyword">SQL</span>逻辑...</span><br><span class="line"><span class="keyword">end</span> loop [end_label];</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">leave label; <span class="comment">-- 退出指定标记的循环体</span></span><br><span class="line">iterate label; <span class="comment">-- 直接进入下一次循环</span></span><br></pre></td></tr></table></figure><h3 id="游标cursor"><a href="#游标cursor" class="headerlink" title="游标cursor"></a>游标cursor</h3><blockquote><p><strong>游标（CURSOR）</strong> 是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">声明游标</span><br><span class="line"><span class="keyword">DECLARE</span> 游标名称 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> 查询语句;</span><br><span class="line">打开游标</span><br><span class="line"><span class="keyword">OPEN</span> 游标名称;</span><br><span class="line">获取游标记录</span><br><span class="line"><span class="keyword">FETCH</span> 游标名称 <span class="keyword">INTO</span> 变量[, 变量 ];</span><br><span class="line">关闭游标</span><br><span class="line"><span class="keyword">CLOSE</span> 游标名称;</span><br></pre></td></tr></table></figure><h3 id="条件处理程序"><a href="#条件处理程序" class="headerlink" title="条件处理程序"></a>条件处理程序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">条件处理程序（Handler） 可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：</span><br><span class="line">DECLARE handler_action HANDLER FOR condition_value [, condition_value] ... statement;</span><br></pre></td></tr></table></figure><blockquote><p>handler_action<br>CONTINUE: 继续执行当前程序<br>EXIT: 终止执行当前程序</p></blockquote><blockquote><p>condition_value<br>SQLSTATE sqlstate_value: 状态码，如 02000<br>SQLWARNING: 所有以 01 开头的 SQLSTATE 代码的简写<br>NOT FOUND: 所有以 02 开头的 SQLSTATE 代码的简写<br>SQLEXCEPTION: 所有没有被 SQLWARNING 或 NOT FOUND 捕获的 SQLSTATE 代码的简写</p></blockquote><h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 存储函数名称([参数列表])</span><br><span class="line"><span class="keyword">RETURNS</span> type [characteristic ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- SQL语句</span></span><br><span class="line">    <span class="keyword">RETURN</span> ...;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><blockquote><ul><li>characteristic 说明<ul><li><code>DETERMINISTIC</code>：相同的输入参数总是产生相同的结果</li><li><code>NO SQL</code>：不包含 SQL 语句。</li><li><code>READS SQL DATA</code>：包含读取数据的语句，但不包含写入数据的语句。</li></ul></li></ul></blockquote><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><blockquote><p>触发器是与表有关的数据库对象，指在 insert&#x2F;update&#x2F;delete 之前或之后，触发并执行触发器中定义的 SQL 语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。</p><p>使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发</p></blockquote><ul><li><p>语法</p><ul><li><p>创建</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">BEFORE<span class="operator">/</span>AFTER <span class="keyword">INSERT</span><span class="operator">/</span><span class="keyword">UPDATE</span><span class="operator">/</span><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">ON</span> tbl_name  <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="comment">-- 行级触发器</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    trigger_stmt ;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TRIGGERS ;</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> [schema_name.]trigger_name ; <span class="comment">-- 如果没有指定 schema_name，默认为当前数据库。</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><blockquote><p>锁是计算机协调多个进程或者线程并发访问某一资源的机制。</p><p>MySQL 中的锁，按照锁的粒度分，分为以下三类：</p><ol><li>全局锁：锁定数据库中的所有表。</li><li>表级锁：每次操作锁住整张表。</li><li>行级锁：每次操作锁住对应的行数据。</li></ol></blockquote><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><blockquote><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的 DML 的写语句，DDL 语句，已经更新操作的事务提交语句都将被阻塞。</p><p>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p></blockquote><ul><li><p>特点</p><ul><li><p>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</p></li><li><p>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志，会导致主从延迟。</p></li><li><p>在 InnoDB 引擎中，我们可以在备份时加上参数<code>--single-transaction</code>参数来完成不加锁的一致性数据备份。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump --single-transaction -uroot -p123456 itcast &gt; itcast.sql</span><br></pre></td></tr></table></figure></li></ul></li><li><p>语法</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock; <span class="comment">--加入全局锁</span></span><br><span class="line">unlock tables;               <span class="comment">--解锁</span></span><br><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p db01 <span class="operator">&gt;</span>D:<span class="operator">/</span>db01.sql <span class="comment">--数据库备份</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><blockquote><p>表级锁，每次操作锁住整张表。锁定力度打，发生锁冲突的概率最高，并发度最低。</p></blockquote><ul><li><p>表锁</p><ul><li><p>分类</p><ul><li>表共享读锁(read lock)</li><li>表独占写锁(write lock)</li></ul></li><li><p>语法</p><ul><li>加锁：lock tables 表名… read&#x2F;write。</li><li>释放锁：unlock tables &#x2F;客户端断开连接。</li></ul><blockquote><p>读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</p></blockquote></li></ul></li><li><p>元数据锁</p><blockquote><p>MDL 加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL 锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免 DML 与 DDL 冲突，保证读写的正确性。</p></blockquote></li><li><p>意向锁</p><blockquote><p>为了避免 DML 在执行时，加的行锁与表锁的冲突，在 InnoDB 中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p></blockquote><ul><li>意向共享锁（IS）：与表锁共享锁（read）兼容，与表锁排它锁（write）互斥。</li><li>意向排它锁（IX）：与表锁共享锁（read）及排它锁（write）都互斥。意向锁之间不会互斥。</li></ul></li></ul><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><blockquote><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB 存储引擎中。</p><p>InnoDB 的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p><ol><li>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行 update 和 delete。在 RC、RR 隔离级别下都支持。</li><li>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行 insert，产生幻读。在 RR 隔离级别下都支持。</li><li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙 Gap。在 RR 隔离级别下支持。</li></ol></blockquote><ul><li>行锁<ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li><li>排它锁（X）：允许获取排它锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排它锁。</li></ul></li></ul><p><img src="https://picbed.algk.com.cn/MySQL/image-20251028195554714.png" alt="image-20251028195554714"></p><blockquote><p>默认情况下，InnoDB 在 REPEATABLE READ 事务隔离级别运行，InnoDB 使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ol><li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li><li>InnoDB 的行锁是针对于索引加的锁，不通过索引条件检索数据，那么 InnoDB 将对表中的所有记录加锁，此时就会升级为表锁。</li></ol></blockquote><ul><li><p>间隙锁和临界锁</p><blockquote><p>默认情况下，InnoDB 在 REPEATABLE READ 事务隔离级别运行，InnoDB 使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ol><li>索引上的等值查询 (唯一索引)，给不存在的记录加锁时，优化为间隙锁 。</li><li>索引上的等值查询 (普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</li><li>索引上的范围查询 (唯一索引)– 会访问到不满足条件的第一个值为止。</li></ol></blockquote></li></ul><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><h3 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h3><p><img src="https://picbed.algk.com.cn/MySQL/image-20251029195315935.png" alt="image-20251029195315935"></p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://picbed.algk.com.cn/MySQL/image-20251029195542689.png" alt="image-20251029195542689"></p><h4 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a>内存架构</h4><p><img src="https://picbed.algk.com.cn/MySQL/image-20251029195838694.png" alt="image-20251029195838694"></p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251029200053318.png" alt="image-20251029200053318"></p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251029200231809.png" alt="image-20251029200231809"></p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251029200345555.png" alt="image-20251029200345555"></p><h4 id="内存架构-1"><a href="#内存架构-1" class="headerlink" title="内存架构"></a>内存架构</h4><p><img src="https://picbed.algk.com.cn/MySQL/image-20251029200833561.png" alt="image-20251029200833561"></p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251029201154685.png" alt="image-20251029201154685"></p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251029201357774.png" alt="image-20251029201357774"></p><h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p><img src="https://picbed.algk.com.cn/MySQL/image-20251029202535535.png" alt="image-20251029202535535"></p><h3 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h3><p><img src="https://picbed.algk.com.cn/MySQL/image-20251029202814450.png" alt="image-20251029202814450"></p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251103190020806.png" alt="image-事务原理"></p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251103190350630.png" alt="image-事务原理"></p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><ul><li><p>当前读</p><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：</p><p>select … lock in share mode (共享锁)，select … for update、update、insert、delete (排他锁) 都是一种当前读。</p></li><li><p>快照读</p><p>简单的 select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p><blockquote><ul><li>Read Committed：每次 select，都生成一个快照读。</li><li>Repeatable Read：开启事务后第一个 select 语句才是快照读的地方。</li><li>Serializable：快照读会退化为当前读。</li></ul></blockquote></li><li><p>MVCC</p><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为 MySQL 实现 MVCC 提供了一个非阻塞读功能。MVCC 的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log 日志、readView。</p></li><li><p>隐藏字段</p><table><thead><tr><th align="center">隐藏字段</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">DB_TRX_ID</td><td align="center">最近修改事务 ID，记录插入这条记录或最后一次修改该记录的事务 ID。</td></tr><tr><td align="center">DB_ROLL_PTR</td><td align="center">回滚指针，指向这条记录的上一个版本，用于配合 undo log，指向上一个版本。</td></tr><tr><td align="center">DB_ROW_ID</td><td align="center">隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</td></tr></tbody></table><blockquote><p>mysql的文件存放在<code>var/lib/mysql</code>文件夹中，mysql提供了查看idb文件的指令<code> idb2 stu.db</code></p></blockquote></li></ul><h4 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a>MVCC实现原理</h4><ul><li><p>undo log</p><ul><li>回滚日志，在 insert、update、delete 的时候产生的便于数据回滚的日志。</li><li>当 insert 的时候，产生的 undo log 日志只在回滚时需要，在事务提交后，可被立即删除。</li><li>而 update、delete 的时候，产生的 undo log 日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</li></ul></li><li><p>undo log 版本链</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251103192211149.png" alt="image-MVCC"></p></li><li><p>ReadView</p><p>ReadView（读视图）是 <strong>快照读</strong> SQL 执行时 MVCC 提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。</p><p>ReadView 中包含了四个核心字段：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务 ID 集合</td></tr><tr><td>min_trx_id</td><td>最小活跃事务 ID</td></tr><tr><td>max_trx_id</td><td>预分配事务 ID，当前最大事务 ID+1（因为事务 ID 是自增的）</td></tr><tr><td>creator_trx_id</td><td>ReadView 创建者的事务 ID</td></tr></tbody></table><p><img src="https://picbed.algk.com.cn/MySQL/image-20251103192623956.png" alt="image-readview原理"></p></li></ul><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><ul><li><p>RC</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251103192849848.png" alt="image-原理演示"></p></li><li><p>RR</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251103192921566.png" alt="image-原理演示"></p></li></ul><h1 id="运维篇"><a href="#运维篇" class="headerlink" title="运维篇"></a>运维篇</h1><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><blockquote><p>错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。</p></blockquote><p>​该日志是默认开启的，默认存放目录 <code>/var/log/</code>，默认的日志文件名为 <code>mysqld.log </code>。查看日志位置：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_error%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://picbed.algk.com.cn/MySQL/image-20251103201647020.png"></p><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但不包括数据查询（SELECT、SHOW）语句。</p><p>作用：①. 灾难时的数据恢复；②. MySQL的主从复制。在MySQL8版本中，默认二进制日志是开启着的，涉及到的参数如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://picbed.algk.com.cn/MySQL/image-20251103203341678.png"></p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251103203431501.png"><br>参数说明：</p><ul><li><p>log_bin_basename：当前数据库服务器的binlog日志的基础名称(前缀)，具体的binlog文 件名需要再该basename的基础上加上编号(编号从000001开始)。</p></li><li><p>log_bin_index：binlog的索引文件，里面记录了当前服务器关联的binlog文件有哪些。</p></li></ul><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>MySQL服务器中提供了多种格式来记录二进制日志，具体格式及特点如下：</p><table><thead><tr><th>日志格式</th><th>含义</th></tr></thead><tbody><tr><td>STATEMENT</td><td>基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在日志文件中。</td></tr><tr><td>ROW</td><td>基于行的日志记录，记录的是每一行的数据变更。（默认）</td></tr><tr><td>MIXED</td><td>混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%binlog_format%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://picbed.algk.com.cn/MySQL/image-20251103204205278.png"></p><p>如果我们需要配置二进制日志的格式，只需要在 <code>/etc/my.cnf </code>中配置 <code>binlog_format</code> 参数即可。</p><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p>由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具 mysqlbinlog 来查看，具体语法：</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251103204911095.png"></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空间。可以通过以下几种方式清理日志：</p><table><thead><tr><th align="center">指令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">reset master</td><td align="center">删除全部 binlog 日志，删除之后，日志编号，将binlog.000001重新开始</td></tr><tr><td align="center">purge master logs to</td><td align="center">删除 * 编号之前的所有日志</td></tr><tr><td align="center">purge master logs before</td><td align="center">‘yyyy-mm-dd hh24:mi:ss’    删除日志为 “yyyy-mm-dd  hh24:mi:ss”  之前产生的所有日志</td></tr></tbody></table><p>也可以在mysql的配置文件中配置二进制日志的过期时间，设置了之后，二进制日志过期会自动删除。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%binlog_expire_logs_seconds%&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%general%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104104637612.png"></p><p>如果需要开启查询日志，可以修改MySQL的配置文件 &#x2F;etc&#x2F;my.cnf 文件，添加如下内容：</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104105012744.png"></p><p>开启了查询日志之后，在MySQL的数据存放目录，也就是 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F; 目录下就会出现 mysql_query.log 文件。之后所有的客户端的增删改查操作都会记录在该日志文件之中，长时间运行后，该日志文件将会非常大。</p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于min_examined_row_limit 的所有的SQL语句的日志，默认未开启。long_query_time 默认为10 秒，最小为 0 精度可以到微秒。</p><p>如果需要开启慢查询日志，需要在MySQL的配置文件 &#x2F;etc&#x2F;my.cnf 中配置如下参数：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#慢查询日志</span><br><span class="line">slow_query_log<span class="operator">=</span><span class="number">1</span></span><br><span class="line">#执行时间参数</span><br><span class="line">long_query_time<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure><p>默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。可以使用 log_slow_admin_statements和 更改此行为 log_queries_not_using_indexes，如下所述。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#记录执行较慢的管理语句</span><br><span class="line">log_slow_admin_statements <span class="operator">=</span><span class="number">1</span></span><br><span class="line">#记录执行较慢的未使用索引的语句</span><br><span class="line">log_queries_not_using_indexes <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>上述所有的参数配置完成之后，都需要重新启动MySQL服务器才可以生效。</p></div><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。</p><p>MySQL支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状复制。</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104110912646.png"></p><p>MySQL 复制的优点主要包含以下三个方面：</p><ul><li>主库出现问题，可以快速切换到从库提供服务。</li><li>实现读写分离，降低主库的访问压力。</li><li>可以在从库中执行备份，以避免备份期间影响主库服务。</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>MySQL主从复制的核心就是 二进制日志，具体的过程如下：</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104111243834.png"></p><p>从上图来看，复制分成三步：</p><ol><li>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</li><li>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</li><li>slave重做中继日志中的事件，将改变反映它自己的数据。</li></ol><h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104111649421.png"></p><p>准备好两台服务器之后，在上述的两台服务器中分别安装好MySQL，并完成基础的初始化准备(安装、密码配置等操作)工作。 其中：</p><ul><li><p>192.168.200.200 作为主服务器master</p></li><li><p>192.168.200.201 作为从服务器slave</p></li></ul><h4 id="主从配置"><a href="#主从配置" class="headerlink" title="主从配置"></a>主从配置</h4><ol><li><p>修改配置文件 &#x2F;etc&#x2F;my.cnf</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#mysql 服务ID，保证整个集群环境中唯一，取值范围：<span class="number">1</span> – <span class="number">232</span><span class="number">-1</span>，默认为<span class="number">1</span> </span><br><span class="line">server<span class="operator">-</span>id<span class="operator">=</span><span class="number">1</span></span><br><span class="line">#是否只读,<span class="number">1</span> 代表只读, <span class="number">0</span> 代表读写</span><br><span class="line">read<span class="operator">-</span><span class="keyword">only</span><span class="operator">=</span><span class="number">0</span></span><br><span class="line">#忽略的数据, 指不需要同步的数据库</span><br><span class="line">#binlog<span class="operator">-</span>ignore<span class="operator">-</span>db<span class="operator">=</span>mysql</span><br><span class="line">#指定同步的数据库</span><br><span class="line">#binlog<span class="operator">-</span>do<span class="operator">-</span>db<span class="operator">=</span>db01</span><br></pre></td></tr></table></figure><ol start="2"><li>重启MySQL服务器</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld;</span><br></pre></td></tr></table></figure></li><li><p>登录mysql，创建远程连接的账号，并授予主从复制权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#创建itcast用户，并设置密码，该用户可在任意主机连接该MySQL服务</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;Root@123456&#x27;</span>;</span><br><span class="line">#为 <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;%&#x27;</span> 用户分配主从复制权限</span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE<span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>通过指令，查看二进制日志坐标</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span>  master  status;</span><br></pre></td></tr></table></figure><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104122045814.png"></p><p>字段含义说明：</p><ul><li><p>file : 从哪个日志文件开始推送日志文件</p></li><li><p>position ： 从哪个位置开始推送日志</p></li><li><p>binlog_ignore_db : 指定不需要同步的数据库</p></li></ul></li></ol><h4 id="从库配置"><a href="#从库配置" class="headerlink" title="从库配置"></a>从库配置</h4><ol><li><p>修改配置文件 &#x2F;etc&#x2F;my.cnf</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#mysql 服务ID，保证整个集群环境中唯一，取值范围：<span class="number">1</span> – <span class="number">2</span><span class="operator">^</span><span class="number">32</span><span class="number">-1</span>，和主库不一样即可</span><br><span class="line">server<span class="operator">-</span>id<span class="operator">=</span><span class="number">2</span></span><br><span class="line">#是否只读,<span class="number">1</span> 代表只读, <span class="number">0</span> 代表读写</span><br><span class="line">read<span class="operator">-</span><span class="keyword">only</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line">#设置超级管理员只读权限</span><br><span class="line">super<span class="operator">-</span>read<span class="operator">-</span><span class="keyword">only</span><span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>重新启动MySQL服务</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld;</span><br></pre></td></tr></table></figure></li><li><p>登录mysql，设置主库配置</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CHANGE REPLICATION SOURCE <span class="keyword">TO</span> SOURCE_HOST<span class="operator">=</span><span class="string">&#x27;192.168.200.200&#x27;</span>, </span><br><span class="line">SOURCE_USER<span class="operator">=</span><span class="string">&#x27;itcast&#x27;</span>, </span><br><span class="line">SOURCE_PASSWORD<span class="operator">=</span><span class="string">&#x27;Root@123456&#x27;</span>, </span><br><span class="line">SOURCE_LOG_FILE<span class="operator">=</span><span class="string">&#x27;binlog.000004&#x27;</span>, </span><br><span class="line">SOURCE_LOG_POS<span class="operator">=</span><span class="number">663</span>;</span><br></pre></td></tr></table></figure><p>上述是8.0.23中的语法。如果mysql是 8.0.23 之前的版本，执行如下SQL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span> MASTER_HOST<span class="operator">=</span><span class="string">&#x27;192.168.200.200&#x27;</span>, </span><br><span class="line">MASTER_USER<span class="operator">=</span><span class="string">&#x27;itcast&#x27;</span>, </span><br><span class="line">MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;Root@123456&#x27;</span>,</span><br><span class="line">MASTER_LOG_FILE<span class="operator">=</span><span class="string">&#x27;binlog.000004&#x27;</span>,</span><br><span class="line">MASTER_LOG_POS<span class="operator">=</span><span class="number">663</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>含义</th><th>8.0.23之前</th></tr></thead><tbody><tr><td>SOURCE_HOST</td><td>主库IP地址</td><td>MASTER_HOST</td></tr><tr><td>SOURCE_USER</td><td>连接主库的用户名</td><td>MASTER_USER</td></tr><tr><td>SOURCE_PASSWORD</td><td>连接主库的密码</td><td>MASTER_PASSWORD</td></tr><tr><td>SOURCE_LOG_FILE</td><td>binlog日志文件名</td><td>MASTER_LOG_FILE</td></tr><tr><td>SOURCE_LOG_POS</td><td>binlog日志文件位置</td><td>MASTER_LOG_POS</td></tr></tbody></table></li><li><p>开启同步操作</p></li></ol>   <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> replica ; #<span class="number">8.0</span><span class="number">.22</span>之后</span><br><span class="line"><span class="keyword">start</span>  slave ;  #<span class="number">8.0</span><span class="number">.22</span>之前</span><br></pre></td></tr></table></figure><ol start="5"><li><p>查看主从同步状态</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> replica  status ;  #<span class="number">8.0</span><span class="number">.22</span>之后</span><br><span class="line"><span class="keyword">show</span>  slave  status ;   #<span class="number">8.0</span><span class="number">.22</span>之前</span><br></pre></td></tr></table></figure><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104124025512.png"></p></li></ol><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104125953007.png"></p><p>随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存储，存在以下性能瓶颈：</p><ol><li><p>IO瓶颈：热点数据太多，数据库缓存不足，产生大量磁盘IO，效率较低。 请求数据太多，带宽不够，网络IO瓶颈。</p></li><li><p>CPU瓶颈：排序、分组、连接查询、聚合统计等SQL会耗费大量的CPU资源，请求数太多，CPU出现瓶颈。</p></li></ol><p>为了解决上述问题，我们需要对数据库进行分库分表处理。</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104130100525.png"></p><blockquote><p>分库分表的中心思想都是将数据分散存储，使得单一数据库&#x2F;表的数据量变小来缓解单一数据库的性能问题，从而达到提升数据库性能的目的。</p></blockquote><h4 id="拆分策略"><a href="#拆分策略" class="headerlink" title="拆分策略"></a>拆分策略</h4><p>分库分表的形式，主要是两种：垂直拆分和水平拆分。而拆分的粒度，一般又分为分库和分表，所以组成的拆分策略最终如下：</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104130501092.png"></p><h4 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h4><ol><li>垂直分库</li></ol><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104130712457.png"></p><p>垂直分库：以表为依据，根据业务将不同表拆分到不同库中。</p><p>特点：</p><ul><li><p>每个库的表结构都不一样。</p></li><li><p>每个库的数据也不一样。</p></li><li><p>所有库的并集是全量数据。</p></li></ul><ol start="2"><li><p>垂直分表</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104131056207.png"></p></li></ol><p>垂直分表：以字段为依据，根据字段属性将不同字段拆分到不同表中。</p><p>特点：</p><ul><li>每个表的结构都不一样。</li><li>每个表的数据也不一样，一般通过一列（主键&#x2F;外键）关联。</li><li>所有表的并集是全量数据。</li></ul><h4 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h4><ol><li><p>水平分库</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104131417248.png"></p></li></ol><p>水平分库：以字段为依据，按照一定策略，将一个库的数据拆分到多个库中。</p><p>特点：</p><ul><li>每个库的表结构都一样。</li><li>每个库的数据都不一样。</li><li>所有库的并集是全量数据。</li></ul><ol start="2"><li><p>水平分表</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104131619696.png"></p></li></ol><p>水平分表：以字段为依据，按照一定策略，将一个表的数据拆分到多个表中。</p><p>特点：</p><ul><li>每个库的表结构都一样。</li><li>每个库的数据都不一样。</li><li>所有库的并集是全量数据。</li></ul><blockquote><p>在业务系统中，为了缓解磁盘IO及CPU的性能瓶颈，到底是垂直拆分，还是水平拆分；具体是分库，还是分表，都需要根据具体的业务需求具体分析。</p></blockquote><h4 id="实现技术"><a href="#实现技术" class="headerlink" title="实现技术"></a>实现技术</h4><ul><li>shardingJDBC：基于AOP原理，在应用程序中对本地执行的SQL进行拦截，解析、改写、路由处理。需要自行编码配置实现，只支持java语言，性能较高。</li><li>MyCat：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言，性能不及前者。</li></ul><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104132139521.png"></p><h3 id="MyCat-概述"><a href="#MyCat-概述" class="headerlink" title="MyCat 概述"></a>MyCat 概述</h3><p>Mycat是开源的、活跃的、基于Java语言编写的MySQL数据库中间件。可以像使用mysql一样来使用mycat，对于开发人员来说根本感觉不到mycat的存在。</p><p>开发人员只需要连接MyCat即可，而具体底层用到几台数据库，每一台数据库服务器里面存储了什么数据，都无需关心。 具体的分库分表的策略，只需要在MyCat中配置即可。</p><p>优势：</p><ul><li><p>性能可靠稳定</p></li><li><p>强大的技术团队</p></li><li><p>体系完善</p></li><li><p>社区活跃</p></li></ul><p>在MyCat的整体结构中，分为两个部分：上面的逻辑结构、下面的物理结构。</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104134622678.png"></p><p>在MyCat的逻辑结构主要负责逻辑库、逻辑表、分片规则、分片节点等逻辑结构的处理，而具体的数据存储还是在物理结构，也就是数据库服务器中存储的。</p><h3 id="MyCat入门"><a href="#MyCat入门" class="headerlink" title="MyCat入门"></a>MyCat入门</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>由于 tb_order 表中数据量很大，磁盘IO及容量都到达了瓶颈，现在需要对 tb_order 表进行数据分片，分为三个数据节点，每一个节点主机位于不同的服务器上, 具体的结构，参考下图：</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104135326284.png"></p><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>准备3台服务器：</p><ul><li>192.168.200.210：MyCat中间件服务器，同时也是第一个分片服务器。</li><li>192.168.200.213：第二个分片服务器。</li><li>192.168.200.214：第三个分片服务器。</li></ul><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104142033749.png"></p><p>并且在上述3台数据库中创建数据库 db01</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ol><li><p>schema.xml在schema.xml中配置逻辑库、逻辑表、数据节点、节点主机等相关信息。具体的配置如下：</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104142659397.png"></p></li><li><p>需要在server.xml中配置用户名、密码，以及用户的访问权限信息，具体的配置如下：</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104142920120.png"></p></li></ol><p>上述的配置表示，定义了两个用户 root 和 user ，这两个用户都可以访问 DB01 这个逻辑库，访问密码都是123456，但是root用户访问DB01逻辑库，既可以读，又可以写，但是 user用户访问DB01逻辑库是只读的。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ol><li>连接MyCat通过如下指令，就可以连接并登陆MyCat。</li></ol>   <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h <span class="number">192.168</span><span class="number">.200</span><span class="number">.210</span> <span class="operator">-</span>P <span class="number">8066</span> <span class="operator">-</span>uroot <span class="operator">-</span>p123456</span><br></pre></td></tr></table></figure><p>   我们看到我们是通过MySQL的指令来连接的MyCat，因为MyCat在底层实际上是模拟了MySQL的协议。</p><ol start="2"><li><p>数据测试</p><p>然后就可以在MyCat中来创建表，并往表结构中插入数据，查看数据在MySQL中的分布情况。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> TB_ORDER (</span><br><span class="line">id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">title <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span> ,</span><br><span class="line"><span class="keyword">PRIMARY KEY</span> (id)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> TB_ORDER(id,title) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;goods1&#x27;</span>); </span><br><span class="line"><span class="keyword">INSERT INTO</span> TB_ORDER(id,title) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;goods2&#x27;</span>); </span><br><span class="line"><span class="keyword">INSERT INTO</span> TB_ORDER(id,title) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">&#x27;goods3&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> TB_ORDER(id,title) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;goods1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> TB_ORDER(id,title) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;goods2&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> TB_ORDER(id,title) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">&#x27;goods3&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> TB_ORDER(id,title) <span class="keyword">VALUES</span>(<span class="number">5000000</span>,<span class="string">&#x27;goods5000000&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> TB_ORDER(id,title) <span class="keyword">VALUES</span>(<span class="number">10000000</span>,<span class="string">&#x27;goods10000000&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> TB_ORDER(id,title) <span class="keyword">VALUES</span>(<span class="number">10000001</span>,<span class="string">&#x27;goods10000001&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> TB_ORDER(id,title) <span class="keyword">VALUES</span>(<span class="number">15000000</span>,<span class="string">&#x27;goods15000000&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> TB_ORDER(id,title) <span class="keyword">VALUES</span>(<span class="number">15000001</span>,<span class="string">&#x27;goods15000001&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>经过测试，我们发现，在往 TB_ORDER 表中插入数据时：</p><ul><li>如果id的值在1-500w之间，数据将会存储在第一个分片数据库中。</li><li>如果id的值在500w-1000w之间，数据将会存储在第二个分片数据库中。</li><li>如果id的值在1000w-1500w之间，数据将会存储在第三个分片数据库中。</li><li>如果id的值超出1500w，在插入数据时，将会报错。</li></ul><p>这是由于分片规则引发的</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104144422855.png"></p></li></ol><h3 id="MyCat配置"><a href="#MyCat配置" class="headerlink" title="MyCat配置"></a>MyCat配置</h3><h4 id="schema-xml"><a href="#schema-xml" class="headerlink" title="schema.xml"></a>schema.xml</h4><p>schema.xml 作为MyCat中最重要的配置文件之一 , 涵盖了MyCat的逻辑库 、 逻辑表 、 分片规则、分片节点及数据源的配置。</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104145434070.png"></p><p>主要包含以下三组标签：</p><ul><li>schema标签</li><li>datanode标签</li><li>datahost标签</li></ul><p><strong>schema标签</strong></p><ol><li>schema 定义逻辑库</li></ol><p>   schema 标签用于定义 MyCat实例中的逻辑库 , 一个MyCat实例中, 可以有多个逻辑库 , 可以通过 schema 标签来划分不同的逻辑库。MyCat中的逻辑库的概念，等同于MySQL中的database概念, 需要操作某个逻辑库下的表时, 也需要切换逻辑库(use xxx)。</p><pre><code>![](https://picbed.algk.com.cn/MySQL/image-20251104145625683.png)</code></pre><blockquote><p>核心属性：</p><ul><li>name：指定自定义的逻辑库库名</li><li>checkSQLschema：在SQL语句操作时指定了数据库名称，执行时是否自动去除；true：自动去除，false：不自动去除</li><li>sqlMaxLimit：如果未指定limit进行查询，列表查询模式查询多少条记录</li></ul></blockquote><ol start="2"><li><p>schema 中的table定义逻辑表</p><p>table 标签定义了MyCat中逻辑库schema下的逻辑表 , 所有需要拆分的表都需要在table标签中定义 。</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104145918800.png"></p><blockquote><p>核心属性：</p><ul><li>name：定义逻辑表表名，在该逻辑库下唯一</li><li>dataNode：定义逻辑表所属的dataNode，该属性需要与dataNode标签中name对应；多个dataNode逗号分隔</li><li>rule：分片规则的名字，分片规则名字是在rule.xml中定义的</li><li>primaryKey：逻辑表对应真实表的主键</li><li>type：逻辑表的类型，目前逻辑表只有全局表和普通表，如果未配置，就是普通表；全局表，配置为 global</li></ul></blockquote></li></ol><p><strong>datanode标签</strong></p><ul><li><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104150300013.png"></p><blockquote><p>核心属性：</p><ul><li>name：定义数据节点名称</li><li>dataHost：数据库实例主机名称，引用自 dataHost 标签中name属性</li><li>database：定义分片所属数据库</li></ul></blockquote></li></ul><p><strong>datahost标签</strong></p><ul><li><p>该标签在MyCat逻辑库中作为底层标签存在, 直接定义了具体的数据库实例、读写分离、心跳语句。</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104150455891.png"></p><blockquote><p>核心属性：</p><ul><li>name：唯一标识，供上层标签使用</li><li>maxCon&#x2F;minCon：最大连接数&#x2F;最小连接数</li><li>balance：负载均衡策略，取值 0,1,2,3</li><li>writeType：写操作分发方式（0：写操作转发到第一个writeHost，第一个挂了，切换到第二个；1：写操作随机分发到配置的writeHost）</li><li>dbDriver：数据库驱动，支持 native、jdbc</li></ul></blockquote></li></ul><h4 id="rule-xml"><a href="#rule-xml" class="headerlink" title="rule.xml"></a>rule.xml</h4><p>rule.xml中定义所有拆分表的规则, 在使用过程中可以灵活的使用分片算法, 或者对同一个分片算法使用不同的参数, 它让分片过程可配置化。主要包含两类标签：tableRule、Function。</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104151349146.png"></p><h4 id="sever-xml"><a href="#sever-xml" class="headerlink" title="sever.xml"></a>sever.xml</h4><p>server.xml配置文件包含了MyCat的系统配置信息，主要有两个重要的标签：system、user。</p><p> <img src="https://picbed.algk.com.cn/MySQL/image-20251104151510201.png"></p><p>在测试权限操作时，我们只需要将 privileges 标签的注释放开。 在 privileges 下的schema标签中配置的dml属性配置的是逻辑库的权限。 在privileges的schema下的table标签的dml属性中配置逻辑表的权限。</p><h2 id="MyCat分片"><a href="#MyCat分片" class="headerlink" title="MyCat分片"></a>MyCat分片</h2><h3 id="垂直拆分-1"><a href="#垂直拆分-1" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>在业务系统中, 涉及以下表结构 ,但是由于用户与订单每天都会产生大量的数据, 单台服务器的数据存储及处理能力是有限的, 可以对数据库表进行拆分, 原有的数据库表如下。</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104190405452.png"></p><p>现在考虑将其进行垂直分库操作，将商品相关的表拆分到一个数据库服务器，订单表拆分的一个数据库服务器，用户及省市区表拆分到一个服务器。最终结构如下：</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104190448615.png"></p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104190707227.png"></p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104191059921.png"></p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251104191142395.png"></p><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><ol><li><p>上传测试SQL脚本到服务器的&#x2F;root目录</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251105191313284.png"></p></li><li><p>执行指令导入测试数据</p><p>重新启动MyCat后，在mycat的命令行中，通过source指令导入表结构，以及对应的数据，查看数据分布情况。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /root/shopping-table.sql</span><br><span class="line">source /root/shopping-insert.sql</span><br></pre></td></tr></table></figure><p>将表结构及对应的测试数据导入之后，可以检查一下各个数据库服务器中的表结构分布情况。 检查是否和我们准备工作中规划的服务器一致。</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251105191452975.png"></p></li><li><p>查询用户的收件人及收件人地址信息(包含省、市、区)。</p><p>在MyCat的命令行中，当我们执行以下多表联查的SQL语句时，可以正常查询出数据。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ua.user_id, ua.contact, p.province, c.city, r.area , ua.address <span class="keyword">from</span> tb_user_address ua ,tb_areas_city c , tb_areas_provinces p ,tb_areas_region r <span class="keyword">where</span> ua.province_id <span class="operator">=</span> p.provinceid <span class="keyword">and</span> ua.city_id <span class="operator">=</span> c.cityid <span class="keyword">and</span> ua.town_id <span class="operator">=</span> r.areaid ;</span><br></pre></td></tr></table></figure><p><img src="https://picbed.algk.com.cn/MySQL/image-20251105191551132.png"></p></li><li><p>查询每一笔订单及订单的收件地址信息(包含省、市、区)。实现该需求对应的SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_id , payment ,receiver, province , city , area <span class="keyword">FROM</span> tb_order_master o , tb_areas_provinces p , tb_areas_city c , tb_areas_region r <span class="keyword">WHERE</span> o.receiver_province <span class="operator">=</span> p.provinceid <span class="keyword">AND</span> o.receiver_city <span class="operator">=</span> c.cityid <span class="keyword">AND</span> o.receiver_region <span class="operator">=</span> r.areaid;</span><br></pre></td></tr></table></figure><p>但是现在存在一个问题，订单相关的表结构是在 192.168.200.213 数据库服务器中，而省市区的数据库表是在 192.168.200.214 数据库服务器中。那么在MyCat中执行是否可以成功呢？</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251105191658059.png"></p><p>经过测试，我们看到，SQL语句执行报错。原因就是因为MyCat在执行该SQL语句时，需要往具体的数据库服务器中路由，而当前没有一个数据库服务器完全包含了订单以及省市区的表结构，造成SQL语句失败，报错。</p><p>对于上述的这种现象，我们如何来解决呢？ 下面我们介绍的全局表，就可以轻松解决这个问题。</p></li><li><p>全局表</p><p>对于省、市、区&#x2F;县表tb_areas_provinces , tb_areas_city , tb_areas_region，是属于数据字典表，在多个业务模块中都可能会遇到，可以将其设置为全局表，利于业务操作。修改schema.xml中的逻辑表的配置，修改 tb_areas_provinces、tb_areas_city、tb_areas_region 三个逻辑表，增加 type 属性，配置为global，就代表该表是全局表，就会在所涉及到的dataNode中创建给表。对于当前配置来说，也就意味着所有的节点中都有该表了。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">=</span>&quot;tb_areas_provinces&quot; dataNode<span class="operator">=</span>&quot;dn1,dn2,dn3&quot; primaryKey<span class="operator">=</span>&quot;id&quot; type<span class="operator">=</span>&quot;global&quot;<span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">=</span>&quot;tb_areas_city&quot; dataNode<span class="operator">=</span>&quot;dn1,dn2,dn3&quot; primaryKey<span class="operator">=</span>&quot;id&quot; type<span class="operator">=</span>&quot;global&quot;<span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">=</span>&quot;tb_areas_region&quot; dataNode<span class="operator">=</span>&quot;dn1,dn2,dn3&quot; primaryKey<span class="operator">=</span>&quot;id&quot; type<span class="operator">=</span>&quot;global&quot;<span class="operator">/</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://picbed.algk.com.cn/MySQL/image-20251105191903794.png"></p><p>配置完毕后，重新启动MyCat。</p><ol><li><p>删除原来每一个数据库服务器中的所有表结构</p></li><li><p>通过source指令，导入表及数据</p></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">source <span class="operator">/</span>root<span class="operator">/</span>shopping<span class="operator">-</span>table.sql</span><br><span class="line">source <span class="operator">/</span>root<span class="operator">/</span>shopping<span class="operator">-</span>insert.sql</span><br></pre></td></tr></table></figure><p>然后执行就可以执行刚才的sql语句了。</p></li></ol><h3 id="水平拆分-1"><a href="#水平拆分-1" class="headerlink" title="水平拆分"></a>水平拆分</h3><ol><li><p>配置</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251105192725555.png"></p></li></ol><h2 id="分片规则"><a href="#分片规则" class="headerlink" title="分片规则"></a>分片规则</h2><ul><li><p>分片规则-范围</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251105193229328.png"></p></li><li><p><img src="https://picbed.algk.com.cn/MySQL/image-20251105193253501.png"></p></li><li><p>分片规则-取模</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251105193422083.png"></p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251105193554073.png"></p></li><li><p>分片规则-一致性hash</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251105193734403.png"></p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251105193835356.png"></p></li><li><p>分片规则-枚举分片</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251105194127810.png"></p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251105194143555.png"></p></li><li><p>分片规则-应用指定</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251105194452791.png"></p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251105194541867.png"></p></li><li><p>分片规则-固定分片哈希算法</p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251105195118146.png"></p><p><img src="https://picbed.algk.com.cn/MySQL/image-20251105195334346.png"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2025/10/30/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2025/10/30/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章"><a href="#这是我的第一篇文章" class="headerlink" title="这是我的第一篇文章"></a>这是我的第一篇文章</h2><div class="note [class] [no-icon] [style] flat"><p>阿拉贡·</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p></div>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
