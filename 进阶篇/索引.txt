- 索引-概述

  - 索引是帮助MySQL高效获取数据的数据结构(有序)。

  - | 优势                                                         | 劣势                                                         |
    | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | 提高数据检索的效率，降低数据库的 IO 成本                     | 索引列也是要占用空间的。                                     |
    | 通过索引列对数据进行排序，降低数据排序的成本，降低 CPU 的消耗。 | 索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行 INSERT、UPDATE、DELETE 时，效率降低。 |

- 索引结构

  | 索引结构    |                             描述                             |
  | ----------- | :----------------------------------------------------------: |
  | B+Tree 索引 |         最常见的索引类型，大部分引擎都支持 B+ 树索引         |
  | Hash 索引   | 底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询 |

- 索引-结构

  - Btree

    ![image-20251025222431224](C:\Users\46814\AppData\Roaming\Typora\typora-user-images\image-20251025222431224.png)

    ```
    具体动态变化的过程可以参考网站: https://www.cs.usfca.edu/~galles/visualization/BTree.html
    ```

  - B+tree

    ![image-20251025222903543](C:\Users\46814\AppData\Roaming\Typora\typora-user-images\image-20251025222903543.png)

    ```
    区别：所有节点都会出现在叶子节点，叶子节点形成一个单向链表。
    ```

  - hash
  
    ![image-20251026101311701](C:\Users\46814\AppData\Roaming\Typora\typora-user-images\image-20251026101311701.png)
  
    ```
    特点：
    1. Hash索引只能用于对等比较(=,in),不支持范围查询(bewteen,>,<,...)
    2.无法利用索引完成排序操作
    3.查询效率高，通常只需要一次检索就可以，效率通常要高于B+tree索引。
    ```
  
    

- 索引-分类

  - | 分类                       | 含义                                                       | 特点                 |
    | -------------------------- | ---------------------------------------------------------- | -------------------- |
    | 聚集索引 (Clustered Index) | 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据 | 必须有，而且只有一个 |
    | 二级索引 (Secondary Index) | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 | 可以存在多个         |

  - 聚集索引选取规则

    ```
    如果存在主键，主键索引就是聚集索引。
    如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。
    如果表没有主键，或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引。
    ```

- 索引-语法

  - 创建索引

    ```
    create [unique|fulltext] index index_name on table_name (index_col_name...);
    ```

  - 查看索引

    ```
    show index from table_name;
    ```

  - 删除索引

    ```
    drop index index_name on table_name;
    ```

- 索引-性能分析

  - 查看执行频次

    ```
    查看数据库语句访问频次
    show global status like 'Com_______';
    ```

  - 慢查询日志

    ```
    慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认 10 秒）的所有 SQL 语句的日志。
    MySQL 的慢查询日志默认没有开启，需要在 MySQL 的配置文件（/etc/my.cnf）中配置如下信息：
    #开启MySQL慢日志查询开关
    slow_query_log=1
    #设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
    long_query_time=2
    配置完后，通过以下指令重启MySQL服务器进行测试，查看满日志文件中记录的信息/var/lib/mysql/localhost-slow.log
    ```
  ```
  
  ```
  
- show profiles
  
    ```
    select @@have_profiling;
    开启profiling:set profiling=1;
    #查看每一条SQL的耗时基本情况
    show profiles;
    #查看指定query_id的SQL语句的各个阶段的耗时情况。
    show profile for query query_id;
    #查询指定query_id的SQL语句的CPU使用情况。
    show profile cpu for query query_id;
    ```
  
  - explain
  
    ```
    #Id
    select 查询的序列号，表示查询中执行 select 子句或者是操作表的顺序 (id 相同，执行顺序从上到下；id 不同，值越大，越先执行)。
    #select_type
    表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE 之后包含了子查询）等
    #type（重要）
    表示连接类型，性能由好到差的连接类型为 NULL、system、const(根据主键和唯一索引查询)、eq_ref、ref(非唯一索引)、range、 index、all 。
    #possible_key
    显示可能应用在这张表上的索引，一个或多个。
    #Key
    实际使用的索引，如果为 NULL，则没有使用索引。
    #Key_len
    表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。
    #rows
    MySQL 认为必须要执行查询的行数，在 innodb 引擎的表中，是一个估计值，可能并不总是准确的。
    #filtered
    表示返回结果的行数占需读取行数的百分比，filtered 的值越大越好。
    ```

- 索引-使用规则

  - 最左前缀法则
  
    ```
    最左前缀法则：如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效 (后面的字段索引失效)。当出现范围查询时，范围查询的右侧列索引失效。
    ```
  
- 索引失效

  - 不要在索引列表上进行运算操作，索引将失效。

  - 字符串类型字段使用时，不加引号，索引将失效。

  - 如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。

  - 用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及到的索引用不到。

  - 如果MySQL评估使用索引比全表更慢，索引失效。
    
  - SQL提示

    - SQL提示是优化数据库的重要手段，就是在SQL语句中加入一些人为的提示来达到目的

    - index

      ```
      explain select * from tb_user use index(idx_user_pro) where profession='软件工程'。
      ## use index表示使用该索引，ignore表示忽略，force表示强制。 
      ```

  - 覆盖索引

    - 尽量使用覆盖索引（也就是说查询的字段，在使用的索引中都包含，也就是减少回表查询），减少select*。

  - 前缀索引

    - 当字段类型为字符串（varchar，text 等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘 IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。

    - 语法

      ```
      create index idx_xxxx on table_name(column(n));
      ```

    - 前缀长度

      可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。

      ```
      select count(distinct substring(字段值,1，5))/count(*) from tb_user;
      ```

- 思考

  ```
  1.为什么InnoDB存储引擎选择使用B+tree索引结构？
  	相对于二叉树，层级更少，搜索效率高。
  	对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低。
  ```
  

- 使用原则

  ```
  针对于数据量较大，且查询比较频繁的表建立索引。
  针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。
  尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
  如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。
  尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。
  要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。
  如果索引列不能存储 NULL 值，请在创建表时使用 NOT NULL 约束它。当优化器知道每列是否包含 NULL 值时，它可以更好地确定哪个索引最有效地用于查询。
  ```

  