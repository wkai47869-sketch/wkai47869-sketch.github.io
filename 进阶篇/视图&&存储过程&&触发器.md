# 视图

## 介绍及基本语法

* 介绍

  视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。

* 语法

  * 创建

    ~~~sql
    create [or replace] view 视图名称[(列表名称)] AS select语句 [with[cascaded|local] check option];
    ~~~

  * 查询

    ~~~sql
    查看创建视图语句：show create view 视图名称;
    查看视图数据：   select * from 视图名称......;
    ~~~

  * 修改

    ~~~sql
    方式一：create [or replace] view 视图名称[(列表名称)] AS select语句 [with[cascaded|local] check option];
    方式二：alter view 视图名称[(列表名称)] AS select语句 [with[cascaded|local] check option];
    ~~~

  * 删除

    ~~~sql
    drop view [if exists] 视图名称
    ~~~

## 检查选项

> 当使用`WITH CHECK OPTION`子句创建视图时，MySQL 会通过视图检查正在更改的每个行，例如插入、更新、删除，以使其符合视图的定义。MySQL 允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql 提供了两个选项：`CASCADED`和`LOCAL`，默认值为`CASCADED`。

### cascaded

~~~sql
create view v1 as select id,name from student where id <= 20
create view v2 as select id , name from v1 where id >= 10 with cascaded check option ;
~~~

>如果加了cascaded要检测当前视图条件还要检测关联的视图条件。关联权限有检查权限。

### local

~~~sql
create view v1 as select id,name from student where id <= 15
create view v2 as select id,name from v1 where id >= 10 with local check option ;
create view v3 as select id,name from v2 where id < 20
~~~

>关联视图没有检查权限

## 更新及作用



* 注意

  要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新：

  1. 聚合函数或窗口函数（SUM ()、MIN ()、MAX ()、COUNT () 等）
  2. DISTINCT
  3. GROUP BY
  4. HAVING
  5. UNION 或者 UNION ALL

* 作用

  - **简单**
      视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。
  - **安全**
      数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据
  - **数据独立**
      视图可帮助用户屏蔽真实表结构变化带来的影响。

# 存储过程

>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。

## 介绍

* 封装，复用
* 可以接受参数，也可以返回参数
* 减少网络交互，效率提升。

## 基本语法

* 创建

  ~~~sql
  create procedure 存储过程名称([参数列表])
  begin
  		--SQL语句
  end;
  ~~~

* 调用

  ~~~sql
  call 名称 ([参数]);
  ~~~

* 查看

  ~~~sql
  select * from information_schema.routines where routines_schema = 'xxx';--查询指定数据库存储过程及状态信息。
  show create procedure 存储过程名称： --查询某个存储过程的定义
  ~~~

* 删除

  ~~~sql
  drop procedure [if exists] 存储过程名称;
  ~~~

  >注意：在命令行中，执行创建存储过程的SQL时，需要通过关键字delimiter指定SQL语句的结束符。

## 变量

### 系统变量

>**系统变量**时MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量(global)和会话变量(session).

* 查看系统变量

  ~~~sql
  show [session|global] variables;				--查看所有系统变量
  show [session|global] variables like '......';  --模糊匹配查找
  select @@[session|global] 系统变量名;			 --查看指定变量的值
  ~~~

* 设置系统变量

  ~~~sql
  set [session|global] 系统变量名 = 值
  set @@[session|global] 系统变量名 = 值
  ~~~

>注意:如果没有指定 SESSION/GLOBAL，默认是 SESSION，会话变量。mysql 服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在 /etc/my.cnf 中配置。

### 用户自定义变量

>**用户定义变量**是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 “@变量名” 使用就可以。其作用域为当前连接。

* 赋值

  ~~~sql
  SET @var_name = expr [, @var_name = expr] ... ;
  SET @var_name := expr [, @var_name := expr] ... ;
  SELECT @var_name := expr [, @var_name := expr] ... ;
  SELECT 字段名 INTO @var_name FROM 表名;
  ~~~

* 使用

  ~~~sql
  SELECT @var_name;
  ~~~

>注意：用户自定义的变量无需对其进行声明或初始化，只不过获取的职位NULL；

### 局部变量

>**局部变量**是根据需要定义的在局部生效的变量，访问之前，需要 DECLARE 声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的 BEGIN ... END 块。

* 声明

  ~~~sql
  DECLARE 变量名 变量类型 [DEFAULT ...];
  ~~~

  >变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME 等。

* 赋值

  ~~~sql
  SET 变量名 = 值;
  SET 变量名 := 值;
  SELECT 字段名 INTO 变量名 FROM 表名 ... ;
  ~~~

## if语句

* 语句

  ~~~sql
  IF 条件 1 THEN
  		......
  ELSEIF 条件 2 THEN    -- 可选
  		......
  ELSE 				 -- 可选
  		......
  END IF;
  ~~~

## 参数(IN 、OUT、INOUT)

* 参数

  | 参数  | 含义                                         | 备注 |
  | ----- | -------------------------------------------- | ---- |
  | IN    | 该类参数作为输入，也就是需要调用时传入值     | 默认 |
  | OUT   | 该类参数作为输出，也就是该参数可以作为返回值 |      |
  | INOUT | 既可以作为输入参数，也可以作为输出           |      |

* 用法

  ~~~sql
  CREATE PROCEDURE 存储过程名称([IN/OUT/INOUT 参数名 参数类型])
  BEGIN
      -- SQL语句
  END;
  ~~~

## case

* 语法一

  ~~~sql
  CASE case_value
      WHEN when_value1 THEN statement_list1
      [ WHEN when_value2 THEN statement_list2 ] ...
      [ ELSE statement_list ]
  END CASE;
  ~~~

* 语法二

  ~~~sql
  CASE
      WHEN search_condition1 THEN statement_list1
      [WHEN search_condition2 THEN statement_list2] ...
      [ELSE statement_list]
  END CASE;
  ~~~

## while

* 语法

  ~~~sql
  WHILE 条件 DO
  	SQL 逻辑...
  END WHILE;
  ~~~

## repeat

* 语法

  ~~~sql
  #先执行一次逻辑，然后判定逻辑是否满足，如果满足，则退出。如果不满足，则继续下一次循环
  REPEAT
  	SQL 逻辑...
  	UNTIL 条件
  END REPEAT;
  ~~~

## loop

>LOOP 实现简单的循环，如果不在 SQL 逻辑中增加退出循环的条件，可以用其来实现简单的死循环。LOOP 可以配合以下两个语句使用：
>
>- LEAVE：配合循环使用，退出循环。
>- ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。

~~~sql
[begin_label:] loop
    SQL逻辑...
end loop [end_label];
~~~

~~~sql
leave label; -- 退出指定标记的循环体
iterate label; -- 直接进入下一次循环
~~~

## 游标cursor

> **游标（CURSOR）** 是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。

~~~sql
声明游标
DECLARE 游标名称 CURSOR FOR 查询语句;
打开游标
OPEN 游标名称;
获取游标记录
FETCH 游标名称 INTO 变量[, 变量 ];
关闭游标
CLOSE 游标名称;
~~~

## 条件处理程序

~~~
条件处理程序（Handler） 可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：
DECLARE handler_action HANDLER FOR condition_value [, condition_value] ... statement;
~~~

> handler_action
> CONTINUE: 继续执行当前程序
> EXIT: 终止执行当前程序

>condition_value
>SQLSTATE sqlstate_value: 状态码，如 02000
>SQLWARNING: 所有以 01 开头的 SQLSTATE 代码的简写
>NOT FOUND: 所有以 02 开头的 SQLSTATE 代码的简写
>SQLEXCEPTION: 所有没有被 SQLWARNING 或 NOT FOUND 捕获的 SQLSTATE 代码的简写

# 存储函数

~~~sql
CREATE FUNCTION 存储函数名称([参数列表])
RETURNS type [characteristic ...]
BEGIN
    -- SQL语句
    RETURN ...;
END;
~~~

> - characteristic 说明
>   - `DETERMINISTIC`：相同的输入参数总是产生相同的结果
>   - `NO SQL`：不包含 SQL 语句。
>   - `READS SQL DATA`：包含读取数据的语句，但不包含写入数据的语句。

# 触发器

> 触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的 SQL 语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。
>
> 使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发

* 语法

  * 创建

    ~~~sql
    CREATE TRIGGER trigger_name
    BEFORE/AFTER INSERT/UPDATE/DELETE
    ON tbl_name  FOR EACH ROW -- 行级触发器
    BEGIN
        trigger_stmt ;
    END;
    ~~~

  * 查看

    ~~~sql
    SHOW TRIGGERS ;
    ~~~

  * 删除

    ~~~sql
    DROP TRIGGER [schema_name.]trigger_name ; -- 如果没有指定 schema_name，默认为当前数据库。
    ~~~

    

  

  

